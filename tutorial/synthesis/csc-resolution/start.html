<!DOCTYPE html>
<html lang="en" dir="ltr" class="no-js">
<head>
    <meta charset="utf-8" />
    <title>Workcraft - tutorial:synthesis:csc-resolution:start</title>
    <script>(function(H){H.className=H.className.replace(/\bno-js\b/,'js')})(document.documentElement)</script>
    <meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="keywords" content="tutorial,synthesis,csc-resolution,start"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../lib/exe/opensearch.html" title="Workcraft"/>
<link rel="start" href="start.html"/>
<link rel="contents" href="start.html" title="Sitemap"/>
<link rel="alternate" type="application/rss+xml" title="Changes" />
<link rel="alternate" type="application/rss+xml" title="Current namespace" />
<link rel="edit" title="Edit this page" href="start.html"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="../../_export/xhtml/tutorial/synthesis/csc-resolution/start.xhtml"/>
<link rel="alternate" type="text/plain" title="Wiki Markup" href="../../_export/raw/tutorial/synthesis/csc-resolution/start.raw"/>
<link rel="canonical" href="http://www.workcraft.org/tutorial/synthesis/csc-resolution/start"/>
<link rel="stylesheet" type="text/css" href="../../lib/exe/css.php.t.dokuwiki-light-export.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='tutorial:synthesis:csc-resolution';var SIG=' --- //[[danilovesky@gmail.com|Danil Sokolov]] 2015/12/23 22:42//';var JSINFO = {"id":"tutorial:synthesis:csc-resolution:start","namespace":"tutorial:synthesis:csc-resolution","plugin_folded":{"hide":"hide","reveal":"reveal"}};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../lib/exe/js.php.t.dokuwiki-light-export.js"></script>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link rel="shortcut icon" href="../../favicon.ico" />
<link rel="apple-touch-icon" href="../../apple-touch-icon.png" />
    </head>

<body>
    <!--[if lte IE 7 ]><div id="IE7"><![endif]--><!--[if IE 8 ]><div id="IE8"><![endif]-->
    <div id="dokuwiki__site"><div id="dokuwiki__top" class="site dokuwiki mode_show tpl_dokuwiki-light-export loggedIn    ">

        
<!-- ********** HEADER ********** -->
<div id="dokuwiki__header"><div class="pad group">

        <h1><a href="../../start.html"  title="Workcraft start page"><img src="../../logo.png" width="327" height="57" alt="" /></a></h1>
    <br><br><br><br>
    <div class="tools group">
        <!-- USER TOOLS -->
<!--
                    <div id="dokuwiki__usertools">
                <h3 class="a11y">User Tools</h3>
                <ul>
                    <li><a href="start.html"  class="action admin" rel="nofollow" title="Admin">Admin</a></li><li><a href="start.html"  class="action profile" rel="nofollow" title="Profile">Profile</a></li><li><a href="start.html"  class="action logout" rel="nofollow" title="Logout">Logout</a></li>                </ul>
            </div>
        -->

        <!-- SEARCH TOOLS -->
<!--
        <div id="dokuwiki__searchtools">
            <h3 class="a11y"></h3>
            <form action="../../start.html" accept-charset="utf-8" class="search" id="dw__search" method="get" role="search"><div class="no"><input type="hidden" name="do" value="search" /><input type="text" id="qsearch__in" accesskey="f" name="id" class="edit" title="[F]" /><input type="submit" value="Search" class="button" title="Search" /><div id="qsearch__out" class="ajax_qsearch JSpopup"></div></div></form>        </div>
-->

        <!-- SITE TOOLS -->
<!--
        <div id="dokuwiki__sitetools">
            <h3 class="a11y">Site Tools</h3>
                            <div class="mobileTools">
                    <form action="../..//doku.html.doku.php.html" method="get" accept-charset="utf-8"><div class="no"><input type="hidden" name="id" value="tutorial:synthesis:csc-resolution:start" /><input type="hidden" name="sectok" value="3ed6b3e0992cb399036638be1fab43c5" /><select name="do" class="edit quickselect" title="Tools"><option value="">Tools</option><optgroup label="Page Tools"><option value="edit">Edit this page</option><option value="revisions">Old revisions</option><option value="backlink">Backlinks</option></optgroup><optgroup label="Site Tools"><option value="recent">Changes</option><option value="media">Manager</option><option value="index">Sitemap</option></optgroup><optgroup label="User Tools"><option value="logout">Logout</option><option value="profile">Profile</option><option value="admin">Admin</option></optgroup></select><input type="submit" value="&gt;" /></div></form>                </div>
                <ul>
                    <li><a href="start.html"  class="action recent" accesskey="r" rel="nofollow" title="Changes [R]">Changes</a></li><li><a href="start.html"  class="action media" rel="nofollow" title="Manager">Manager</a></li><li><a href="start.html"  class="action index" accesskey="x" rel="nofollow" title="Sitemap [X]">Sitemap</a></li>                </ul>
                    </div>
    </div>
-->

    <!-- BREADCRUMBS -->
        
    <hr class="a11y" />
</div></div><!-- /header -->

        <div class="wrapper group">

            
            <!-- ********** CONTENT ********** -->
            <div id="dokuwiki__content"><div class="pad group">
                <div class="pageId"><span>tutorial:synthesis:csc-resolution:start</span></div>
                <div class="page group">
                                                            <!-- wikipage start -->
                    <!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="#what_are_csc_conflicts">What are CSC conflicts?</a></div></li>
<li class="level1"><div class="li"><a href="#automatic_resolution_of_csc_conflicts">Automatic resolution of CSC conflicts</a></div></li>
<li class="level1"><div class="li"><a href="#manual_resolution_of_csc_conflicts_if_you_cannot_help_it">Manual resolution of CSC conflicts (if you cannot help it)</a></div></li>
<li class="level1"><div class="li"><a href="#visualisation_of_csc_conflicts">Visualisation of CSC conflicts</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="#visualisation_of_csc_conflicts_at_the_level_of_state_graphs">Visualisation of CSC conflicts at the level of state graphs</a></div></li>
<li class="level2"><div class="li"><a href="#visualisation_of_csc_conflicts_at_the_level_of_stgs">Visualisation of CSC conflicts at the level of STGs</a></div></li>
</ul>
</li>
<li class="level1"><div class="li"><a href="#transformations_for_resolving_encoding_conflicts">Transformations for resolving encoding conflicts</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="#signal_insertion">Signal insertion</a></div></li>
<li class="level2"><div class="li"><a href="#concurrency_reduction">Concurrency reduction</a></div></li>
<li class="level2"><div class="li"><a href="#making_extra_inputs_available">Making extra inputs available</a></div></li>
<li class="level2"><div class="li"><a href="#relative_timing_assumptions">Relative timing assumptions</a></div></li>
</ul>
</li>
<li class="level1"><div class="li"><a href="#solutions">Solutions</a></div></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 id="resolution_of_encoding_csc_conflicts">Resolution of encoding (CSC) conflicts</h1>
<div class="level1">
<div class="wrap_center wrap_round wrap_todo plugin_wrap" style="width: 60%;">
<p>
!!! UNDER CONSTRUCTION !!!
</p>

<p>
!!! UNDER CONSTRUCTION !!!
</p>

<p>
!!! UNDER CONSTRUCTION !!!
</p>
</div>
<p>
A common issue in synthesis of speed-independent circuits from <em>Signal Transition Graphs (STGs)</em> are <em>encoding conflicts</em>, a.k.a. <em>Complete State Coding (CSC) conflicts.</em> Detection and resolution of CSC conflicts is an important part of the design process.
</p>

</div>

<h2 id="what_are_csc_conflicts">What are CSC conflicts?</h2>
<div class="level2">

<p>
CSC conflicts arise when two semantically different (i.e. enabling different output or internal signals) reachable states have the same <em>encoding,</em> i.e. the same values of all the signals. For example, consider the following STG specifying the read phase of the <a href="../vme/start.html" class="wikilink1" title="tutorial:synthesis:vme:start">VME bus controller</a>.
</p>

<p>
<img src="stg-vme-read.png" class="mediacenter" title="Read phase of the VME bus controller" alt="Read phase of the VME bus controller" />
</p>

<p>
One can see the conflicting states at the level of the <em>state graph</em> of this STG, which can be generated via the <em>Conversion→Finite State Transducer [Petrify]</em> menu, and is shown below (after some manual layout). Note that the encoding of each state is given in its label (after &#039;_&#039;) with the following order of signals: <code><span style='color:red; '>dsr</span></code>, <code><span style='color:red; '>ldtack</span></code>, <code><span style='color:blue; '>d</span></code>, <code><span style='color:blue; '>dtack</span></code>, <code><span style='color:blue; '>lds</span></code>.
</p>

<p>
<img src="vme-read-sg.png" class="mediacenter" title="The state graph of the above VME bus controller STG" alt="The state graph of the above VME bus controller STG" />
</p>

<p>
The two highlighted states have the same encoding, 11001, but are semantically different: in one of them the circuit must produce <code><span style='color:blue; '>d+</span></code> and is not allowed to produce <code><span style='color:blue; '>lds-</span></code>, and in the other the circuit must produce <code><span style='color:blue; '>lds-</span></code> and is not allowed to produce <code><span style='color:blue; '>d+</span></code>. Since the circuit can only &#039;see&#039; the signal values but not the tokens in the STG, these two states are indistinguishable from its point of view, and so the specification is not directly implementable – one has first to resolve this CSC conflict by transforming the STG.
</p>

</div>

<h2 id="automatic_resolution_of_csc_conflicts">Automatic resolution of CSC conflicts</h2>
<div class="level2">

<p>
In most practical cases CSC conflicts can be resolved automatically, via the <em>Tools→Encoding conflicts→Resolve CSC conflicts [Mpsat]</em> or <em>Tools→Encoding conflicts→Resolve CSC conflicts [Petrify]</em> menu items. For the VME bus controller STG shown above, both MPSat and Petrify happen to generate essentially the same solution:
</p>

<p>
<img src="stg-vme-read_resolved.png" class="mediacenter" title="The modified VME bus controller STG with an additional internal signal resolving the CSC conflict" alt="The modified VME bus controller STG with an additional internal signal resolving the CSC conflict" />
</p>

<p>
The state graph of this STG is shown below (after manual layout). Note that the binary encodings of the states have one extra bit now corresponding to the newly inserted signal (this is the last bit in the encodings). The two highlighted states correspond to the conflicted states of the original STG – one can see that now their encodings differ in the last bit and so the CSC conflict disappears. Intuitively, the newly inserted signal introduces extra memory into the circuit, helping it to trace its current state and disambiguate the previously conflicted states.
</p>

<p>
<img src="vme-read_resolved-sg.png" class="mediacenter" title="The state graph of the modified VME bus controller STG" alt="The state graph of the modified VME bus controller STG" />
</p>

<p>
Once the encoding conflicts are resolved, several kinds of circuit implementations can be automatically synthesised by the Petrify or MPSat back-ends (via the <em>Synthesis</em> menu):
</p>
<ul>
<li class="level1"><div class="li">
 complex-gate implementation;
</div></li>
<li class="level1"><div class="li">
 generalised C-element (gC) implementation;
</div></li>
<li class="level1"><div class="li">
 standard C implementation.
</div></li>
</ul>


<p>
E.g. for the former, the following next-state functions for the output and internal signals are automatically derived: 
</p>
<pre class="code">[d] = csc1 ldtack; 
[dtack] = d; 
[lds] = d + csc1; 
[csc1] = dsr (ldtack&#039; + csc1);</pre>

<p>
The total number of literals in the right-hand side of these equations is 8 – this intermediate metrics is often used for evaluating the quality of the CSC resolution process before technology mapping. The circuit corresponding to these equations is shown below (after manual layout). Note that the gate with feedback implements <code><span style='color:green; '>csc1</span></code>, and that the implementation of <code><span style='color:blue; '>dtack</span></code> is a buffer gate – it&#039;s just a wire.
</p>

<p>
<img src="circuit-vme-read_resolved.png" class="mediacenter" title="A complex-gate implementation of VME bus controller" alt="A complex-gate implementation of VME bus controller" />
</p>

</div>

<h4 id="exercise_1">Exercise 1</h4>
<div class="level4">

<p>
Download the following STG from <a href="#refnotes:1:note1" name="refnotes:1:ref1" class="refnotes-ref note-popup">[1]</a>: <span class="wrap_download "><a href="sram-master.work" class="media mediafile mf_work" title="tutorial:synthesis:csc-resolution:sram-master.work (9 KB)">SRAM controller (MASTER).</a> (9.02 KiB, <acronym title="Modified: 2015-11-10 22:05.59">1M ago</acronym>)</span>:
</p>

<p>
<img src="sram-master.png" class="mediacenter" title="STG specification of SRAM master controller" alt="STG specification of SRAM master controller" />
</p>
<ul>
<li class="level1"><div class="li">
 Automatically resolve the encoding conflicts in it using the <em>Tools→Encoding conflicts→Resolve CSC conflicts [MPSat]</em> and <em>Tools→Encoding conflicts→Resolve CSC conflicts [Petrify]</em> menu items. Save the results as <code>sram-master-csc-mpsat.work</code> and <code>sram-master-csc-petrify.work</code>.
</div></li>
<li class="level1"><div class="li">
 Synthesise the complex-gate implementations of these two STGs, noting the number of literals in each case (can be found in the <em>Output</em> window).
</div></li>
</ul>


</div>

<h2 id="manual_resolution_of_csc_conflicts_if_you_cannot_help_it">Manual resolution of CSC conflicts (if you cannot help it)</h2>
<div class="level2">

<p>
As explained above, the resolution of CSC conflicts is automated, and the tools generally do a good job. However, there are some rare situations when manual resolution is used, e.g.:
</p>
<ul>
<li class="level1"><div class="li">
 for personal enlightenment you wish to learn about CSC conflicts and techniques that can be used for their resolution;
</div></li>
<li class="level1"><div class="li">
 you have a lot of time, and the process for you is more important than its outcome <img src="../../lib/images/smileys/facepalm.gif" class="icon" alt="m(" />;
</div></li>
<li class="level1"><div class="li">
 automatic resolution failed, so you have no choice;
</div></li>
<li class="level1"><div class="li">
 you are an experienced designer, and have reasons to believe that some potentially dangerous transformations like concurrency reduction may improve your circuit so considerably that you are willing to take the risk of shooting yourself in a foot.
</div></li>
</ul>

<div class="wrap_alert wrap_round plugin_wrap">
<p>
If you do not fall into any of the above categories, you should be content with automatic resolutions of encoding conflicts and skip the rest of this tutorial. Otherwise you are welcome to the shady world of tools&#039; internals, with many dark corners, strange heuristics, dangerous transformations, and unsavoury hacks…
</p>
</div>
<p>
For manual resolution, the conflicts have to be
</p>
<ul>
<li class="level1"><div class="li"> <strong>detected</strong> – this is fully automated;</div>
</li>
<li class="level1"><div class="li"> <strong>visualised</strong> – two kinds of visualisation are explained below: at the level of state graphs (works only for toy examples) and at the level of STGs;</div>
</li>
<li class="level1"><div class="li"> <strong>resolved</strong> – several commonly used ways of resolving CSC conflicts are briefly explained below.</div>
</li>
</ul>

</div>

<h2 id="visualisation_of_csc_conflicts">Visualisation of CSC conflicts</h2>
<div class="level2">

<p>
Workcraft supports two ways of visualising encoding conflicts:
</p>
<ul>
<li class="level1"><div class="li">
 highlighting conflicting states in the state graph;
</div></li>
<li class="level1"><div class="li">
 showing <em>conflict cores</em> in the STG <a href="#refnotes:1:note2" name="refnotes:1:ref2" class="refnotes-ref note-popup">[2]</a> <a href="#refnotes:1:note3" name="refnotes:1:ref3" class="refnotes-ref note-popup">[3]</a> <a href="#refnotes:1:note4" name="refnotes:1:ref4" class="refnotes-ref note-popup">[4]</a>. 
</div></li>
</ul>


<p>
The former approach only works for toy examples where the state graph is small enough to fit on a screen and to be comprehensible for a human. However, for more realistic examples state graphs tend to be large as the number of reachable states is often exponential in the size of the STG, especially if the STG has a lot of concurrency (this is the well-known <em>state space explosion</em> problem, a.k.a. <em>state explosion</em> problem). The recommended visualisation technique is based on conflict cores – it works directly with the STG and so is much more human-friendly.
</p>

</div>

<h3 id="visualisation_of_csc_conflicts_at_the_level_of_state_graphs">Visualisation of CSC conflicts at the level of state graphs</h3>
<div class="level3">

<p>
An example of this kind of visualisation is shown above for the VME bus controller example. The idea is to highlight the conflicted states in the state graph with the same colour (i.e. each conflicted encoding gets its own colour). To build the state graph of the STG and highlight the conflicted states, use the <em>Conversion→Finite State Transducer [Petrify]</em> menu. 
</p>

<p>
There are two main problems with this kind of visualisation:
</p>
<ul>
<li class="level1"><div class="li">
 the state graph may be too large to be of any use for a human;
</div></li>
<li class="level1"><div class="li">
 even if the state graph is of moderate size, it is difficult to see how one can transform <em>the original STG</em> to resolve the conflicts.
</div></li>
</ul>


<p>
To illustrate these problems, consider the following examples. The following STG specifies a 4-way paralleliser: in response to the parent handshake <code><span style='color:red; '>r</span></code> / <code><span style='color:blue; '>a</span></code> it initiates four child handshakes in parallel:
</p>

<p>
<img src="par4.png" class="mediacenter" title="4-way paralleliser" alt="4-way paralleliser" />
</p>

<p>
Though this STG is very small and comprehensible, due to high concurrency its state graph is large (628 states) and is of limited utility for humans:
</p>

<p>
<img src="par4-sg.png" class="mediacenter" title="State graph of 4-way paralleliser" alt="State graph of 4-way paralleliser" />
</p>

<p>
The following STG specifies a part of an A2D converter <a href="#refnotes:1:note5" name="refnotes:1:ref5" class="refnotes-ref note-popup">[5]</a>.
</p>

<p>
<img src="a2d.png" class="mediacenter" title="Part of an A2D converter" alt="Part of an A2D converter" />
</p>

<p>
The corresponding state graph is not particularly large, but there are several CSC conflicts and it is not straightforward by looking at it to understate the causes of these conflicts and to find transformations resolving them:
</p>

<p>
<img src="a2d-sg.png" class="mediacenter" title="Stage graph of the A2D converter STG" alt="Stage graph of the A2D converter STG" />
</p>

</div>

<h3 id="visualisation_of_csc_conflicts_at_the_level_of_stgs">Visualisation of CSC conflicts at the level of STGs</h3>
<div class="level3">

<p>
An alternative and recommended method of visualising encoding conflicts is based on showing the <em>conflict cores</em> in the STG <a href="#refnotes:1:note2" name="refnotes:1:ref6" class="refnotes-ref note-popup">[2]</a> <a href="#refnotes:1:note3" name="refnotes:1:ref7" class="refnotes-ref note-popup">[3]</a> <a href="#refnotes:1:note4" name="refnotes:1:ref8" class="refnotes-ref note-popup">[4]</a>. Consider the VME bus controller STG shown above. The two conflicted states can be reached from the initial state by the following two traces:
</p>

<p>
<code><span style='color:red; '>dsr+</span>, <span style='color:blue; '>lds+</span>, <span style='color:red; '>ldtack+</span></code><br/>

<code><span style='color:red; '>dsr+</span>, <span style='color:blue; '>lds+</span>, <span style='color:red; '>ldtack+</span>, <span style='color:blue; '>d+</span>, <span style='color:blue; '>dtack+</span>, <span style='color:red; '>dsr-</span>, <span style='color:blue; '>d-</span>, <span style='color:blue; '>dtack-</span>, <span style='color:red; '>dsr+</span></code>
</p>

<p>
By taking the difference of two traces we get a set of transitions forming a <em>conflict core</em> shown below. To see it in Workcraft, use the <em>Verification→Complete State Coding (all conflicts) [MPSat]</em> menu and then select <em>Show selected cores</em> in the <em>Tool controls</em> panel.
</p>

<p>
<img src="screenshot-vme-coremap.png" class="mediacenter" title="VME bus controller: core map" alt="VME bus controller: core map" />
</p>

<p>
Note that this core has several important properties helping the user to understand the cause of the conflict and find ways to resolve it:
</p>
<ul>
<li class="level1"><div class="li">
 the states just before and just after the core are in encoding conflict;
</div></li>
<li class="level1"><div class="li">
 the numbers of <code>s+</code> and <code>s-</code> transitions in the core are the same for each signal <code>s</code> as the states just before and just after the core have the same encoding;
</div></li>
<li class="level1"><div class="li">
 if the transformation upsets this balance of signals in the core (e.g. <span style='color:green; '>csc+</span> is inserted somewhere inside the core and <span style='color:green; '>csc-</span> is inserted somewhere outside the core) then the associated conflicts become resolved.
</div></li>
</ul>


<p>
The core map for the 4-way paralleliser is as follows. Note that it is much more comprehensible than the state graph: Each concurrent branch has a single conflict core inside it, and one can resolve these cores e.g. by inserting the rising transitions of four new internal signals into these cores, and the corresponding falling transitions outside of these cores.
</p>
<div class="wrap_info wrap_round plugin_wrap">
<p>
Each core is given a different colour. If there are several cores, it is possible to show any subset of them by selecting the required cores in the <em>Tool controls</em> panel.
</p>
</div>
<p>
<img src="screenshot-par4-coremap.png" class="mediacenter" title="4-way paralleliser: core map" alt="4-way paralleliser: core map" />
</p>

<p>
The core map corresponding to the A2D controller example is shown below on the left. Note that in this case there are five cores, some of which overlap (and so some of the transitions are highlighted with several colours as they belong to several cores). Core overlaps can be exploited during the resolution process – by inserting <code><span style='color:green; '>csc+</span></code> into the overlap of several cores one can destroy these cores, killing several birds with one stone. Furthermore, one can insert <code><span style='color:green; '>csc-</span></code> into some of the remaining cores, increasing thus the number of birds killed by the same stone.
</p>

<p>
<img src="screenshot-a2d-core_and_height_map.png" class="mediacenter" title="A2D converter: Core map (left) and height map (right)" alt="A2D converter: Core map (left) and height map (right)" />
</p>

<p>
When there are multiple overlapping cores, one can quickly identify the promising areas where a signal insertion (or some other transformation) would eliminate as many encoding conflicts as possible by considering the <em>core density map</em> – for the A2D controller example it is shown above on the right. The idea is to count how many cores a transition belongs to, and the higher this number is, the darker is the shade used to highlight this transition. The analogy is with a topographic map where darker shades show higher altitudes – the &#039;peaks&#039; with the darkest shade are good areas where a single signal insertion can eliminate the maximum number of cores. E.g. in the A2D controller example the highest peak is formed by the transitions <code><span style='color:red; '>Laf+</span></code>, <code><span style='color:blue; '>Ar-</span></code>, <code><span style='color:blue; '>Lr-</span></code> and <code><span style='color:red; '>Laf-</span></code> that belong to the same four cores. Hence inserting <code><span style='color:green; '>csc+</span></code> somewhere in this peak eliminates these four cores. The remaining core can be also eliminated if <code><span style='color:green; '>csc-</span></code> is inserted into it, i.e. all the encoding conflicts in this example can be resolved by a single signal insertion.
</p>
<div class="plugin_wrap"><div class="wrap_column wrap_half plugin_wrap"><div class="table sectionedit11"><table class="inline">
	<tr class="row0">
		<td class="col0"><img src="a2d-csc-mpsat.png" class="mediacenter" alt="" /></td>
	</tr>
	<tr class="row1">
		<td class="col0 centeralign">  MPSat solution  </td>
	</tr>
</table></div>
</div><div class="wrap_column wrap_half plugin_wrap"><div class="table sectionedit14"><table class="inline">
	<tr class="row0">
		<td class="col0"><img src="a2d-csc-petrify.png" class="mediacenter" alt="" /></td>
	</tr>
	<tr class="row1">
		<td class="col0 centeralign">  Petrify solution  </td>
	</tr>
</table></div>
</div></div>
<p>
The above STGs show two alternative signal insertions resolving all the conflicts with a single new internal signal in the A2D converter. They were derived automatically by the MPSat and Petrify back-ends, accessible via the <em>Tools→Encoding conflicts→Resolve CSC conflicts [MPSat]</em> and <em>Tools→Encoding conflicts→Resolve CSC conflicts [Petrify]</em> menu items. The complex-gate implementations corresponding to the resulting two STGs are as follows:
</p>
<pre class="code">// MPSat: 14 literals
[Ar] = (Laf&#039; + csc1&#039;) (Ad&#039; + Ar) Lam&#039;
[Lr] = Ar (Ad start csc1&#039; + Lr)
[ready] = csc1
[csc1] = start csc1 + Laf</pre>
<pre class="code">// Petrify: 15 literals
[Ar] = Laf&#039; Lam&#039; (Ar + Ad&#039;); 
[Lr] = csc0&#039; (Ad Ar start + Laf); 
[ready] = csc0 + Laf; 
[csc0] = Ar&#039; Laf + csc0 start;</pre>

<p>
Note that MPSat&#039;s solution is smaller, but Petrify&#039;s solution has more concurrency.
</p>
<div class="wrap_tip wrap_round plugin_wrap">
<p>
MPSat and Petrify are different back-end tools that perform the actual resolution of CSC conflicts. These tools use different methods and somewhat different cost functions, so it makes sense to try both of them and then choose the solution that better fits the designer&#039;s goals (in terms of area, performance, etc.).
</p>
</div>
</div>

<h2 id="transformations_for_resolving_encoding_conflicts">Transformations for resolving encoding conflicts</h2>
<div class="level2">

<p>
Below several ways of resolving encoding conflicts are outlined. They are all supported by tools, with various levels of automation. It is difficult to beat the tools on their own field, as they employ advanced techniques and use complicated cost functions that would be difficult for humans to compute. However, the human designer has information and capabilities that are not available to the tools, in particular the high-level understanding of the design, the possibility to change the contract between the circuit and the environment (and re-design the latter if required), etc. So you need to think “outside the box” to beat the tools.
</p>

</div>

<h3 id="signal_insertion">Signal insertion</h3>
<div class="level3">

<p>
Severity level: <span style='color:green; '>Paracetamol</span>
</p>

<p>
New internal signals can be added to the STG in such a way that its external behaviour (i.e. the &#039;contract&#039; with the environment) stays unchanged. These internal signals add memory to the circuit helping it to trace its current state. The encodings of the states get longer due to the new signals, which helps to disambiguate the states that previously had the same encodings.
</p>

<p>
When inserting a new internal signal, say <code><span style='color:green; '>csc</span></code>, one has to make sure that:
</p>
<ul>
<li class="level1"><div class="li">
 no input is directly delayed (triggered) by the transitions of <code><span style='color:green; '>csc</span></code>, as this is not implementable (the environment is oblivious to internal signals);
</div></li>
<li class="level1"><div class="li">
 the consistency is not violated, i.e. the rising and falling edges of <code><span style='color:green; '>csc</span></code> alternate in every execution, always starting from the same edge;
</div></li>
<li class="level1"><div class="li">
 the output-persistency is not violated, i.e. <code><span style='color:green; '>csc</span></code> must not disable or be disabled by any other signal;
</div></li>
<li class="level1"><div class="li">
 <code><span style='color:green; '>csc</span></code> resolves some encoding conflicts;
</div></li>
<li class="level1"><div class="li">
 when inserting a transition, say <code><span style='color:green; '>csc-</span></code>, outside the core, make sure that it is not adjacent to the core, i.e. there are some other transitions separating the core from <code><span style='color:green; '>csc-</span></code> (otherwise the core will suck <code><span style='color:green; '>csc-</span></code> in and re-appear with both <code><span style='color:green; '>csc+</span></code> and <code><span style='color:green; '>csc-</span></code> inside it).
</div></li>
</ul>


<p>
In addition to these, one should try to heuristically optimise the final implementation, as the way the signals are inserted affects the quality of the resulting circuit very significantly. Note, however, that “the quality of the circuit” cannot be defined at this point, as an STG with CSC conflicts is not directly implementable. However, various heuristics for signal insertions are known to be beneficial, e.g.:
</p>
<ul>
<li class="level1"><div class="li">
 increasing the number of resolved cores;
</div></li>
<li class="level1"><div class="li">
 reducing the number of transitions of <code><span style='color:green; '>csc</span></code>;
</div></li>
<li class="level1"><div class="li">
 sequential insertions of transitions of <code><span style='color:green; '>csc</span></code> often result in a smaller circuit with less concurrency, whereas concurrent insertions result in a more concurrent operation at the expense of the area (it is important to note that this more concurrent operation does not necessarily improve the performance of the circuit, as the more complicated implementation imposes additional overheads);
</div></li>
<li class="level1"><div class="li">
 reducing the number of signals triggering or triggered by <code><span style='color:green; '>csc</span></code> often leads to a simpler implementation of <code><span style='color:green; '>csc</span></code> and those signals (one can also replace one or more triggers of some signal by <code><span style='color:green; '>csc</span></code>);
</div></li>
<li class="level1"><div class="li">
 <em>locking</em> <code><span style='color:green; '>csc</span></code> with some existing signals (two signals are called <em>locked</em> if their transitions alternate in every execution).
</div></li>
</ul>


<p>
Examples and techniques for signal insertion have already been presented above. Considerations when using signal insertion:
</p>
<ul>
<li class="level1"><div class="li">
 behaviour is preserved and so the contract with the environment stays the same <img src="../../lib/images/smileys/icon_smile.gif" class="icon" alt=":-)" />;
</div></li>
<li class="level1"><div class="li">
 inserted signals have to be implemented, i.e. the logic becomes more complicated <img src="../../lib/images/smileys/icon_sad.gif" class="icon" alt=":-(" />.
</div></li>
</ul>

<div class="wrap_tip wrap_round plugin_wrap">
<p>
When trying to resolve encoding conflicts by signal insertion you will be competing with the tools on their own field (as the contract with the environment is unchanged, no insight that is not already available to the tool is exploited), and so are unlikely to significantly improve the automatically generated solution. As an example, consider the (very simple) VME bus controller STG above. MPSat backend reports 18 (!) different ways of resolving the encoding conflict by inserting a single signal, and heuristically chooses the best one. How many of these can you find? For more complicated examples the number of ways to insert a signal grows very fast, and the tool will have an edge over the human designer.
</p>
</div>
</div>

<h4 id="exercise_2">Exercise 2</h4>
<div class="level4">

<p>
For the STG in Exercise 1:
</p>
<ul>
<li class="level1"><div class="li">
 Visualise the conflicts using the <em>Verification→Complete State Coding (all cores) [MPSat]</em> menu item.
</div></li>
<li class="level1"><div class="li">
 Meditate on the cores map and the core density map until you understand the causes of the encoding conflicts.
</div></li>
<li class="level1"><div class="li">
 Manually resolve the encoding conflicts by signal insertion as explained above. Make sure that no input is delayed by the newly introduced signals, and that the consistency is not violated – the latter can be verified with the help of <em>Verification→Consistency [MPSat]</em> menu item.
</div></li>
<li class="level1"><div class="li">
 After all the conflicts are resolved, synthesise the complex-gate implementation using the <em>Synthesis→Complex gate [MPSat]</em> menu item.
</div></li>
<li class="level1"><div class="li">
 Compare the number of literals in your solution with those in Exercise 1. If yours is significantly worse, repeat the previous two steps inserting signals differently, until you are either happy with your solution or frustrated and cannot be bothered any more.
</div></li>
</ul>


</div>

<h3 id="concurrency_reduction">Concurrency reduction</h3>
<div class="level3">

<p>
Severity level: <span style='color:orange; '>Antibiotic</span>
</p>

<p>
Another commonly used transformation for resolving CSC conflicts is <em>concurrency reduction</em> (CR) <a href="#refnotes:1:note6" name="refnotes:1:ref9" class="refnotes-ref note-popup">[6]</a>. The idea is to sequentialise some concurrent transitions in the STG by introducing new arcs, in such a way that some of the conflicted states become unreachable. This may or may not decrease the performance: note that the loss of concurrency may be more than offset by simpler logic in some cases.
</p>
<div class="wrap_important wrap_center wrap_round plugin_wrap">
<p>
This transformation may change the behaviour of the STG in significant ways, and break the contract with the environment! It is up to the designer to ensure that the modified STG still makes sense, and that the environment either can cope with the changed contract or is re-designed for the modified contract – the tools do not have sufficient information / capability to make these kinds of decisions.
</p>
</div>
<p>
A possible CR resolving the encoding conflict in the VME bus controller is shown below. The amber arc orders two previously concurrent STG transitions, pulling <code><span style='color:blue; '>lds-</span></code> into the core, which breaks the balance and destroys the core.
</p>

<p>
<img src="vme-cr-benign.png" class="mediacenter" title="VME bus controller: resolving the CSC conflict by concurrency reduction" alt="VME bus controller: resolving the CSC conflict by concurrency reduction" />
</p>
<div class="wrap_center wrap_round wrap_info plugin_wrap">
<p>
The semantics of CR arcs coincides with that of usual arcs, but it is convenient for the designer to see which arcs were original and which were added later for various technical reasons, so CR arcs are highlighted as thick amber arcs.
</p>
</div>
<p>
The state graph after this CR is shown below: Two of the formerly reachable states have become unreachable (they are faded out in the picture). One of these states used to be involved in an encoding conflict, and so eliminating this state resolves the conflict. 
</p>

<p>
<img src="vme-read-cr-sg.png" class="mediacenter" title="The state graph of the VME bus controller STG after concurrency reduction" alt="The state graph of the VME bus controller STG after concurrency reduction" />
</p>

<p>
The resulting complex-gate implementation has 10 literals, which happens to be worse than the solution obtained using signal insertion.
</p>
<pre class="code">[d] = ldtack dsr lds; 
[dtack] = dtack lds + d; 
[lds] = dsr (lds + ldtack&#039;) + d; </pre>

<p>
However, often CR results in smaller circuits than signal insertion as for the latter the newly inserted signals have to be implemented.
</p>

<p>
We distinguish a special kind of <em>innocuous</em> CRs, which do not introduce any extra causal dependencies on the inputs, i.e. if the original STG could produce some output at some state, the modified STG in the corresponding state will be able to produce this output too, perhaps after firing some other outputs first, but <em>without waiting for any inputs from the environment.</em> For example, suppose the original STG at some state could produce outputs <code><span style='color:blue; '>o1</span></code> and <code><span style='color:blue; '>o2</span></code> concurrently, i.e. in any order, and the applied CR fixes this order to <code><span style='color:blue; '>o1</span></code> → <code><span style='color:blue; '>o2</span></code>. Since the original environment was prepared to receive these outputs in any order, fixing the order will do no harm. In other words, innocuous CRs modify the contract with the environment in a safe way: they do not make any extra assumptions about the environment, but provide more guarantees to it (about the order of transitions). Hence, the modified STG will work correctly in any environment in which the original STG would have worked correctly. 
<span class="wrap_important ">
All the other CRs are called <em>risky</em> – they require extra assumptions about the environment and have to be vetted by both the designer of the STG and the designer of the environment.
</span>
</p>

<p>
For example, the CR used in the VME bus controller STG above is innocuous: since the environment formerly was prepared to receive <code><span style='color:blue; '>lds-</span></code> and <code><span style='color:blue; '>dtack-</span></code> in any order, fixing this order to <code><span style='color:blue; '>lds-</span></code> → <code><span style='color:blue; '>dtack-</span></code> is harmless. An alternative (and highly problematic!) way to apply CR to resolve the conflict in VME bus controller is shown below. 
</p>
<div class="wrap_center wrap_round wrap_alert plugin_wrap">
<p>
<img src="vme-cr-malignant.png" class="mediacenter" title="VME bus controller: resolving the CSC conflict by concurrency reduction" alt="VME bus controller: resolving the CSC conflict by concurrency reduction" />
</p>

<p>
This CR is <em>risky</em> (i.e. not <em>innocuous</em> according to the above definition) as it changes the contract with the environment in a dangerous way: the modified STG waits for the environment to supply <code><span style='color:red; '>ldtack-</span></code> before it can produce <code><span style='color:blue; '>dtack-</span></code>. If the environment in turn waits for <code><span style='color:blue; '>dtack-</span></code> before sending <code><span style='color:red; '>ldtack-</span></code> (e.g. because the designer next-door used CR to resolve some encoding conflicts in the environment without checking with you <img src="../../lib/images/smileys/icon_wink.gif" class="icon" alt=";-)" />), a deadlock ensues. However, even if that is not the case, there is a higher-level problem with this CR, which cannot be automatically detected even in principle: The applied CR pulls both <code><span style='color:blue; '>lds-</span></code> and <code><span style='color:red; '>ldtack-</span></code> into the core, which completely sequentialises the behaviour (the transitions become totally ordered) and <em>destroys the VME bus controller&#039;s purpose in life</em> (which is to ensure concurrent operation of the bus and the device interacting with the controller).
</p>

<p>
The complex-gate implementation has only 7 literals, which is smaller than any of the implementations above, but, as explained, it is totally useless (other then as an illustration of CR pitfalls).
</p>
<pre class="code">[d] = dsr ldtack; 
[dtack] = dtack ldtack + d; 
[lds] = d + dsr;</pre>
</div>
<p>
The following two schematic pictures show how to resolve encoding conflicts using CRs <a href="#refnotes:1:note3" name="refnotes:1:ref10" class="refnotes-ref note-popup">[3]</a> <a href="#refnotes:1:note4" name="refnotes:1:ref11" class="refnotes-ref note-popup">[4]</a>. The idea is to pull one or more existing transitions into the core, upsetting its balance and thus eliminating it.
</p>

<p>
<img src="concurrency-reduction-simple.png" class="mediacenter" title="Core elimination by concurrency reduction." alt="Core elimination by concurrency reduction." />
</p>

<p>
In the presence of choices, the CRs may be more complicated, as illustrated below <a href="#refnotes:1:note3" name="refnotes:1:ref12" class="refnotes-ref note-popup">[3]</a> <a href="#refnotes:1:note4" name="refnotes:1:ref13" class="refnotes-ref note-popup">[4]</a>. An extra place may be necessary in such a case to handle all the branches of the choice to avoid violating the consistency of the STG. (This case is mentioned here for completeness, but we do not use such CRs in the rest of the tutorial.)
</p>

<p>
<img src="concurrency-reduction-choice.png" class="mediacenter" title="Core elimination by concurrency reduction in presence of a choice." alt="Core elimination by concurrency reduction in presence of a choice." />
</p>

<p>
<img src="../../lib/images/smileys/fixme.gif" class="icon" alt="FIXME" /> [ explain the -r option of MPSat? ]
</p>

<p>
Four alternative ways to use CR to resolve the encoding conflicts in the A2D example are shown below – only one (any) of the four amber arcs is added. The reason any of these CRs resolves all the conflicts is interesting:
</p>
<ul>
<li class="level1"><div class="li">
 <code><span style='color:blue; '>ready+</span></code> and perhaps also <code><span style='color:red; '>start-</span></code> are pulled into the overlap of four cores (forming the highest peak) and destroy these four cores;
</div></li>
<li class="level1"><div class="li">
 at the same time,  <code><span style='color:blue; '>Lr-</span></code>, <code><span style='color:red; '>Laf-</span></code>, and perhaps <code><span style='color:blue; '>Ar-</span></code> are pulled into the remaining core destroying it too.
</div></li>
</ul>


<p>
<img src="screenshot-a2d-cr.png" class="mediacenter" title="A2D controller: 4 different ways to resolve the CSC conflicts by concurrency reduction" alt="A2D controller: 4 different ways to resolve the CSC conflicts by concurrency reduction" />
</p>
<pre class="code">// innocuous CR: ready+ -&gt; Ar-; 14 literals
[Ar] = (Lam&#039; ready&#039; + Laf&#039; ready) (Ar + Ad&#039;); 
[Lr] = Ar (Ad ready&#039; start + Laf); 
[ready] = ready start + Laf; </pre>
<pre class="code">// innocuous CR: ready+ -&gt; Lr-; 14 literals
[Ar] = Laf&#039; Lam&#039; (Ar + Ad&#039;); 
[Lr] = ready&#039; (Ar Ad start + Laf) + Laf Ar; 
[ready] = ready start + Laf; </pre>
<div class="wrap_center wrap_round wrap_important plugin_wrap"><pre class="code">// risky CR: start- -&gt; Ar-; 11 literals
[Ar] = (Laf&#039; start&#039; + Lam&#039; start) (Ar + Ad&#039;); 
[Lr] = Ar (start Ad + Laf); 
[ready] = Laf;</pre>
<pre class="code">// risky CR: start- -&gt; Lr-; 11 literals
[Ar] = Laf&#039; Lam&#039; (Ar + Ad&#039;); 
[Lr] = start (Ad Ar + Laf) + Laf Ar; 
[ready] = Laf; </pre>
</div>
<p>
The CRs <code><span style='color:blue; '>ready+</span></code> → <code><span style='color:blue; '>Ar-</span></code> and <code><span style='color:blue; '>ready+</span></code> → <code><span style='color:blue; '>Lr-</span></code> are innocuous, and the corresponding complex-gate implementations both have 14 literals – which happens to be the same as MPSat&#039;s automatic resolution by signal insertion.
</p>

<p>
The complex-gate implementations for the CRs <code><span style='color:red; '>start-</span></code> → <code><span style='color:blue; '>Ar-</span></code> and <code><span style='color:red; '>start-</span></code> → <code><span style='color:blue; '>Lr-</span></code> are much smaller (only 11 literals) and so advantageous from the area point of view. However, in contrast to the previous two CRs, these CRs are risky: they rely on the environment producing <code><span style='color:red; '>start-</span></code> soon after <code><span style='color:blue; '>ready+</span></code>, as otherwise many transitions get delayed. Hence these CRs have to be carefully considered by the human designer and agreed with the environment&#039;s designer. In this particular case, Alex Yakovlev (one of the designers of this A2D controller) explained that:
</p>
<ul>
<li class="level1"><div class="li">
 <code><span style='color:red; '>start</span></code> / <code><span style='color:blue; '>ready</span></code> is an “external” handshake to the user of the A2D controller; a ubiquitous component like an A2D converter should not rely on the environment to send <code><span style='color:red; '>start-</span></code> fast;
</div></li>
<li class="level1"><div class="li">
 <code><span style='color:red; '>start-</span></code> may be controlled by a clock, and so be <em>very</em> slow;
</div></li>
<li class="level1"><div class="li">
 there are situations, however, when <code><span style='color:red; '>start-</span></code> is fast.
</div></li>
</ul>


<p>
When choosing a concurrency reduction, one has to make sure that:
</p>
<ul>
<li class="level1"><div class="li">
 no input is directly delayed by the new arc (this will definitely change the contract with the environment, expecting it to wait for some transitions before delivering this input);
</div></li>
<li class="level1"><div class="li">
 the added arc cannot accumulate unbounded number of tokens, i.e. the STG remains bounded;
</div></li>
<li class="level1"><div class="li">
 the output-persistency is not violated;
</div></li>
<li class="level1"><div class="li">
 no deadlocks have been introduced (e.g. if concurrency reduction is used both to simplify the circuit and, independently, the environment then all the added arcs may accidentally form a loop leading to a deadlock due to circular waiting);
</div></li>
<li class="level1"><div class="li">
 the concurrency reduction resolves some of the CSC conflicts.
</div></li>
</ul>


<p>
(Note that the consistency cannot be violated by concurrency reduction, as it can only restrict the behaviour of the STG, i.e. no new traces can be introduced.) One should also prefer innocuous CRs, and use the risky ones only if there is a <em>very</em> compelling reason to do so, and remember to vet these with the designer of the environment!
</p>

<p>
In addition to these, one should try to heuristically optimise the final implementation, using similar heuristics to those explained above for signal insertion. In particular, one should try not to introduce new signal triggers if at all possible.
</p>

<p>
Considerations when using concurrency reduction:
</p>
<ul>
<li class="level1"><div class="li">
 no new signals to implement <img src="../../lib/images/smileys/icon_smile.gif" class="icon" alt=":-)" />;
</div></li>
<li class="level1"><div class="li">
 reduced state graph and so more don&#039;t-cares in minimisation tables, which may result in a better implementation <img src="../../lib/images/smileys/icon_smile.gif" class="icon" alt=":-)" />;
</div></li>
<li class="level1"><div class="li">
 risky CRs change the behaviour in significant ways, breaking the contract with the environment <img src="../../lib/images/smileys/icon_sad.gif" class="icon" alt=":-(" />;
</div></li>
<li class="level1"><div class="li">
 risky CRs can introduce deadlocks <img src="../../lib/images/smileys/icon_sad.gif" class="icon" alt=":-(" />;
</div></li>
<li class="level1"><div class="li">
 even when no deadlocks are introduced, risky CRs may drastically deteriorate the performance due to sequentialisation without the designer realising this (cf. the latter concurrency reduction in VME bus controller example above).
</div></li>
</ul>

<div class="wrap_center wrap_round wrap_tip plugin_wrap">
<p>
CRs can be used for simplifying the logic, even when there are no encoding conflicts.
</p>
</div>
</div>

<h4 id="exercise_3">Exercise 3</h4>
<div class="level4">

<p>
For the STG in Exercise 1:
</p>
<ul>
<li class="level1"><div class="li">
 Manually resolve the encoding conflicts by concurrency reduction.
</div><ul>
<li class="level2"><div class="li">
 Think which events can be pulled into cores to break the balance.
</div></li>
<li class="level2"><div class="li">
 Use only innocuous CRs, as this tutorial does not provide sufficient information about the environment of this STG to vet risky CRs.
</div></li>
<li class="level2"><div class="li">
 Try to reduce the number of signal triggers – this is likely to result in a smaller complex-gate implementation.
</div></li>
<li class="level2"><div class="li">
 Do not forget to highlight the CRs by making the corresponding arcs amber and thick (with bigger arrowheads) by editing the properties of the corresponding arcs in the <em>Property editor</em>.
</div></li>
</ul>
</li>
<li class="level1"><div class="li">
 Once all the encoding conflicts are resolved, synthesise the complex-gate implementation and compare the number of literals with that in the solutions to previous exercises.
</div></li>
<li class="level1"><div class="li">
 Even after the encoding conflicts are resolved, use more innocuous CRs to improve the number of literals in the complex-gate implementation. You should be able to get a solution with 23 literals without much effort.
</div></li>
</ul>


</div>

<h3 id="making_extra_inputs_available">Making extra inputs available</h3>
<div class="level3">

<p>
Severity level: <span style='color:orange; '>Antibiotic</span>
</p>

<p>
It can happen that including extra input signals from the environment, which are not strictly necessary for implementing the STG, helps to resolve encoding conflicts. This requires restructuring the STG in major ways. This technique is currently underexplored, in particular there are no clear guidelines on how to choose the signals that need to be included, other than appealing to the designer&#039;s “understanding of the system” and “creativity”. For small systems one can try to include all (or as many as possible) signals from the environment and see whether the complex-gate implementations becomes simpler and which of the newly included signals occur in the equations. In particular, if the environment (or a part thereof) is specified by STGs, one can compose all or some of them with the STG specifying the circuit (<em>Tools→Composition→Parallel composition [PComp]</em> menu item) and try to synthesise the composed STG: it may happen that the implementations of some of the signals become simpler, and one can find useful signals by examining the equations. Note however that the composed STG may be large and difficult to synthesise.
</p>

<p>
Consider the following STG specifying a part of an SRAM controller <a href="#refnotes:1:note1" name="refnotes:1:ref14" class="refnotes-ref note-popup">[1]</a>.
</p>

<p>
<img src="screenshort_flip_slave_coremap.png" class="mediacenter" title="A part of an SRAM controller (FlipSlave): core map" alt="A part of an SRAM controller (FlipSlave): core map" />
</p>

<p>
Automatic resolution inserts two new internal signals and yields the following complex-gate implementation with 18 literals:
</p>
<pre class="code">[WE] = B0&#039; csc1&#039; + B1&#039; csc0&#039;; 
[done] = B0 csc1&#039; + B1 csc0&#039; + WE flip&#039;; 
[csc0] = B0&#039; csc0 + csc1&#039; + flip&#039;; 
[csc1] = B1&#039; csc1 + csc0&#039; + flip&#039;; </pre>

<p>
Alternatively, one can resolve some of the conflicts using innocuous CRs as shown below:
</p>

<p>
<img src="screenshort_flip_slave_intermediate_coremap.png" class="mediacenter" title="A part of an SRAM controller (FlipSlave) with some encoding conflicts resolved by innocuous CRs: core map" alt="A part of an SRAM controller (FlipSlave) with some encoding conflicts resolved by innocuous CRs: core map" />
</p>

<p>
The above STG still has some encoding conflicts, but they can be resolved by inserting a single signal, yielding the following complex-gate implementation with 18 literals:
</p>
<pre class="code">[WE] = done&#039; (B1&#039; flip + csc0&#039; + WE); 
[done] = WE (B1 csc0 + done) + B0 csc0&#039; + flip done; 
[csc0] = csc0 (WE + B0) + done + flip&#039;; </pre>

<p>
However, by vigorously applying “understanding of the system” and “creativity”, the designers of this SRAM controllers observed that two signals in the environment, <code><span style='color:red; '>D0</span></code> and <code><span style='color:red; '>D1</span></code>, can help the implementation to trace its current state and get rid of the encoding conflicts (in fact, any of these signal would have been sufficient, but it is better to include them both for the reasons explained below). The STG had to be manually restructured to include these two signals:
</p>

<p>
<img src="flip_slave_no_cr.png" class="mediacenter" title="A part of an SRAM controller (FlipSlave) with extra input signals added to resolve the encoding conflicts" alt="A part of an SRAM controller (FlipSlave) with extra input signals added to resolve the encoding conflicts" />
</p>

<p>
This STG is free from encoding conflicts, and yields the following implementation with 11 literals:
</p>
<pre class="code">[WE] = flip (D0&#039; B1&#039; + B0&#039; D0); 
[done] = (WE + flip) (D0 + B1) (B0 + D0&#039;); </pre>

<p>
Furthermore, one can simplify this implementation by applying two innocuous CRs as shown below. Note that these CRs are used not for conflict resolution, but for simplifying the implementation to help with subsequent technology mapping.
</p>

<p>
<img src="flip_slave_final.png" class="mediacenter" title="Using CRs to simplify the complex-gate implementation" alt="Using CRs to simplify the complex-gate implementation" />
</p>

<p>
The resulting complex-gate implementation has only 8 literals:
</p>
<pre class="code">[WE] = done&#039; flip; 
[done] = (WE + flip) (D0 + B1) (B0 + D0&#039;); </pre>

<p>
Note that <code><span style='color:red; '>D1</span></code> is not used in this implementation. However, one can deploy it instead of <code><span style='color:red; '>D0&#039;</span></code>, getting rid of the inversion that is likely to be finally mapped to an inverter with a timing assumption on its delay:
</p>
<pre class="code">[WE] = done&#039; flip; 
[done] = (WE + flip) (D0 + B1) (B0 + D1); </pre>

<p>
Note that this manual modification of the circuit has to be formally verified against the STG using <em>Verification→Conformation, deadlock and hazard (reuse unfolding) [MPSat]</em> menu item.
</p>

<p>
Considerations when adding extra inputs:
</p>
<ul>
<li class="level1"><div class="li">
 no new signals to implement – the extra signals are already implemented in the environment  <img src="../../lib/images/smileys/icon_smile.gif" class="icon" alt=":-)" />;
</div></li>
<li class="level1"><div class="li">
 not clear how to choose the new inputs <img src="../../lib/images/smileys/icon_sad.gif" class="icon" alt=":-(" />;
</div></li>
<li class="level1"><div class="li">
 need to re-design the STG, often manually, changing the contract with the environment <img src="../../lib/images/smileys/icon_sad.gif" class="icon" alt=":-(" />.
</div></li>
</ul>


</div>

<h3 id="relative_timing_assumptions">Relative timing assumptions</h3>
<div class="level3">

<p>
Severity level: <img src="surgery.9d0ca6efc1ea9c4b35bb2ecf0b787c95.png" class="media" alt="" width="90" />
</p>

<p>
<img src="../../lib/images/smileys/fixme.gif" class="icon" alt="FIXME" /> “This event will happen faster than that one”
</p>

<p>
<img src="../../lib/images/smileys/fixme.gif" class="icon" alt="FIXME" /> Relative vs. absolute timing assumptions, and their robustness
</p>

<p>
<img src="../../lib/images/smileys/fixme.gif" class="icon" alt="FIXME" /> Break speed-independence, and generally problematic
</p>

<p>
<img src="../../lib/images/smileys/fixme.gif" class="icon" alt="FIXME" /> Similar to concurrency reductions, but the introduced arcs are special, in particular they don&#039;t trigger signals
</p>

<p>
<img src="../../lib/images/smileys/fixme.gif" class="icon" alt="FIXME" /> Can “delay” inputs
</p>

<p>
<img src="../../lib/images/smileys/fixme.gif" class="icon" alt="FIXME" /> [VME example with TA delaying an input]
</p>

<p>
<img src="vme-ta.png" class="mediacenter" title="VME bus controller: resolving the CSC conflict by concurrency reduction" alt="VME bus controller: resolving the CSC conflict by concurrency reduction" />
</p>

<p>
<img src="../../lib/images/smileys/fixme.gif" class="icon" alt="FIXME" /> [State graph for the above]
</p>

<p>
Considerations when using timing assumptions:
</p>
<ul>
<li class="level1"><div class="li">
 no new signals to implement <img src="../../lib/images/smileys/icon_smile.gif" class="icon" alt=":-)" />;
</div></li>
<li class="level1"><div class="li">
 reduced state graph and so more don&#039;t-cares in minimisation tables, which may result in a better implementation <img src="../../lib/images/smileys/icon_smile.gif" class="icon" alt=":-)" />;
</div></li>
<li class="level1"><div class="li">
 break speed-independence of the circuit, so inherently fragile due to variability (manufacturing, temperature, voltage, etc.) <img src="../../lib/images/smileys/icon_sad.gif" class="icon" alt=":-(" />;
</div></li>
<li class="level1"><div class="li">
 require deep understanding of theory and the circuit&#039;s behaviour <img src="../../lib/images/smileys/icon_sad.gif" class="icon" alt=":-(" />;
</div></li>
<li class="level1"><div class="li">
 introduce place &amp; route constraints, and need extensive validation <img src="../../lib/images/smileys/icon_sad.gif" class="icon" alt=":-(" />.
</div></li>
</ul>


</div>

<h2 id="solutions">Solutions</h2>
<div class="level2">

<p>
Download all the Workcraft models discussed in this section here:
</p>

<p>
<img src="../../lib/images/smileys/fixme.gif" class="icon" alt="FIXME" />

&lt;wrap download&gt;{{CSC-resolution.zip|CSC resolution models}}&lt;/wrap&gt;

</p>













</div>
<div class="refnotes">
<hr>
<div class="notes">
<div class="note left">
<b><a name="refnotes:1:note1" class="nolink">[1]</a></b>
<span id="refnotes:1:note1:text">
Formal Design and Verification of an Asynchronous SRAM Controller. <img src="../../lib/images/smileys/fixme.gif" class="icon" alt="FIXME" /> Details to be added.
</span></div>
<div class="note left">
<b><a name="refnotes:1:note2" class="nolink">[2]</a></b>
<span id="refnotes:1:note2:text">
A. Madalinski, A. Bystrov, V. Khomenko, and A. Yakovlev: <a href="http://dx.doi.org/10.1049/ip-cdt:20030831" class="urlextern" title="http://dx.doi.org/10.1049/ip-cdt:20030831"  rel="nofollow">Visualization and Resolution of Coding Conflicts in Asynchronous Circuit Design</a>. Special Issue on Best Papers from DATE&#039;03, IEE Proceedings: Computers &amp; Digital Techniques 150(5) (2003) 285-293.
</span></div>
<div class="note left">
<b><a name="refnotes:1:note3" class="nolink">[3]</a></b>
<span id="refnotes:1:note3:text">
V. Khomenko, A. Madalinski and A. Yakovlev: <a href="http://dl.acm.org/citation.cfm?id=2366080" class="urlextern" title="http://dl.acm.org/citation.cfm?id=2366080"  rel="nofollow">Resolution of Encoding Conflicts by Signal Insertion and Concurrency Reduction Based on STG Unfoldings</a>. Special Issue on Best Papers from ACSD&#039;06, IOS Press, Fundamenta Informaticae 86(3) (2008) 299-323.
</span></div>
<div class="note left">
<b><a name="refnotes:1:note4" class="nolink">[4]</a></b>
<span id="refnotes:1:note4:text">
<a href="http://dx.doi.org/10.1109/TVLSI.2008.2012156" class="urlextern" title="http://dx.doi.org/10.1109/TVLSI.2008.2012156"  rel="nofollow">Efficient Automatic Resolution of Encoding Conflicts Using STG Unfoldings</a>. Special Section on Asynchronous Circuits and Systems, Joint Publication of IEEE Circuits and Systems Society, IEEE Computer Society and IEEE Solid-State Circuits Society, IEEE Transactions on Very Large Scale Integration (VLSI) Systems 17(7) (2009) 855-868. Also available <a href="http://homepages.cs.ncl.ac.uk/victor.khomenko/papers/ieee-tvlsi-csc.pdf" class="urlextern" title="http://homepages.cs.ncl.ac.uk/victor.khomenko/papers/ieee-tvlsi-csc.pdf"  rel="nofollow">here</a>.
</span></div>
<div class="note left">
<b><a name="refnotes:1:note5" class="nolink">[5]</a></b>
<span id="refnotes:1:note5:text">
D.J. Kinniment, B. Gao, A. Yakovlev, and F. Xia: <a href="http://dx.doi.org/10.1109/ASYNC.1998.666506" class="urlextern" title="http://dx.doi.org/10.1109/ASYNC.1998.666506"  rel="nofollow">Towards Asynchronous A-D Conversion</a>. Proc. ASYNC (1998) 206–215.
</span></div>
<div class="note left">
<b><a name="refnotes:1:note6" class="nolink">[6]</a></b>
<span id="refnotes:1:note6:text">
J. Cortadella, M. Kishinevsky, A. Kondratyev, L. Lavagno, and A. Yakovlev: <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.46.7861&amp;rep=rep1&amp;type=pdf" class="urlextern" title="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.46.7861&amp;rep=rep1&amp;type=pdf"  rel="nofollow">Automatic Handshake Expansion and Reshuffling Using Concurrency Reduction</a>. Proc. HWPN (1998) 86-110.
</span></div>
</div>
</div>

                    <!-- wikipage stop -->
                                    </div>
<!--
                                    <div class="docInfo"><bdi>tutorial/synthesis/csc-resolution/start.txt</bdi> · Last modified: 2015/11/30 10:31 by <bdi>danil</bdi></div>
                -->
                            </div></div><!-- /content -->

            <hr class="a11y" />

            <!-- PAGE ACTIONS -->
<!--
            <div id="dokuwiki__pagetools">
                            <h3 class="a11y">Page Tools</h3>
                <div class="tools">
                    <ul>
                        <li><a href="start.html"  class="action edit" accesskey="e" rel="nofollow" title="Edit this page [E]"><span>Edit this page</span></a></li><li><a href="start.html"  class="action revs" accesskey="o" rel="nofollow" title="Old revisions [O]"><span>Old revisions</span></a></li><li><a href="start.html"  class="action backlink" rel="nofollow" title="Backlinks"><span>Backlinks</span></a></li><li><a href="#dokuwiki__top"  class="action top" accesskey="t" rel="nofollow" title="Back to top [T]"><span>Back to top</span></a></li><li><a href="start.html"  class="action export_pdf" rel="nofollow" title="Export to PDF"><span>Export to PDF</span></a></li><li><a href="start.html"  class="action siteexport_addpage" title="Add page"><span>Export Page</span></a></li>                    </ul>
                </div>
                        </div>
-->
        </div><!-- /wrapper -->

        
<!-- ********** FOOTER ********** -->
<div id="dokuwiki__footer"><div class="pad">
    <!--
    <div class="buttons">
                <a href="http://www.dokuwiki.org/donate" title="Donate" ><img
            src="../../lib/tpl/dokuwiki-light-export/images/button-donate.gif" width="80" height="15" alt="Donate" /></a>
        <a href="http://www.php.net" title="Powered by PHP" ><img
            src="../../lib/tpl/dokuwiki-light-export/images/button-php.gif" width="80" height="15" alt="Powered by PHP" /></a>
        <a href="http://validator.w3.org/check/referer" title="Valid HTML5" ><img
            src="../../lib/tpl/dokuwiki-light-export/images/button-html5.png" width="80" height="15" alt="Valid HTML5" /></a>
        <a href="http://jigsaw.w3.org/css-validator/check/referer?profile=css3" title="Valid CSS" ><img
            src="../../lib/tpl/dokuwiki-light-export/images/button-css.png" width="80" height="15" alt="Valid CSS" /></a>
        <a href="http://dokuwiki.org/" title="Driven by DokuWiki" ><img
            src="../../lib/tpl/dokuwiki-light-export/images/button-dw.png" width="80" height="15" alt="Driven by DokuWiki" /></a>
    </div>
-->

<!--
    <div class="userInfo">
        Logged in as:: danil    </div>
-->
</div></div><!-- /footer -->

    </div></div><!-- /site -->

    <div class="no"><img  width="2" height="1" alt="" /></div>
    <div id="screen__mode" class="no"></div>    <!--[if ( lte IE 7 | IE 8 ) ]></div><![endif]-->
</body>
</html>

