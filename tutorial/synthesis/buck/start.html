<!DOCTYPE html>
<html lang="en" dir="ltr" class="no-js">
<head>
    <meta charset="utf-8" />
    <title>Workcraft - tutorial:synthesis:buck:start</title>
    <script>(function(H){H.className=H.className.replace(/\bno-js\b/,'js')})(document.documentElement)</script>
    <meta name="generator" content="DokuWiki"/>
<meta name="robots" content="noindex,nofollow"/>
<meta name="keywords" content="tutorial,synthesis,buck,start"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../lib/exe/opensearch.html" title="Workcraft"/>
<link rel="start" href="start.html"/>
<link rel="contents" href="start.html" title="Sitemap"/>
<link rel="alternate" type="application/rss+xml" title="Changes" />
<link rel="alternate" type="application/rss+xml" title="Current namespace" />
<link rel="edit" title="Edit this page" href="start.html"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="../../_export/xhtml/tutorial/synthesis/buck/start.xhtml"/>
<link rel="alternate" type="text/plain" title="Wiki Markup" href="../../_export/raw/tutorial/synthesis/buck/start.raw"/>
<link rel="canonical" href="http://www.workcraft.org/tutorial/synthesis/buck/start"/>
<link rel="stylesheet" type="text/css" href="../../lib/exe/css.php.t.dokuwiki-light-export.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='tutorial:synthesis:buck';var SIG=' --- //[[danilovesky@gmail.com|Danil Sokolov]] 2015/08/03 15:36//';var JSINFO = {"id":"tutorial:synthesis:buck:start","namespace":"tutorial:synthesis:buck","plugin_folded":{"hide":"hide","reveal":"reveal"}};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../lib/exe/js.php.t.dokuwiki-light-export.js"></script>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link rel="shortcut icon" href="../../favicon.ico" />
<link rel="apple-touch-icon" href="../../apple-touch-icon.png" />
    </head>

<body>
    <!--[if lte IE 7 ]><div id="IE7"><![endif]--><!--[if IE 8 ]><div id="IE8"><![endif]-->
    <div id="dokuwiki__site"><div id="dokuwiki__top" class="site dokuwiki mode_show tpl_dokuwiki-light-export loggedIn    ">

        
<!-- ********** HEADER ********** -->
<div id="dokuwiki__header"><div class="pad group">

        <h1><a href="../../start.html"  title="Workcraft start page"><img src="../../logo.png" width="327" height="57" alt="" /></a></h1>
    <br><br><br><br>
    <div class="tools group">
        <!-- USER TOOLS -->
<!--
                    <div id="dokuwiki__usertools">
                <h3 class="a11y">User Tools</h3>
                <ul>
                    <li><a href="start.html"  class="action admin" rel="nofollow" title="Admin">Admin</a></li><li><a href="start.html"  class="action profile" rel="nofollow" title="Profile">Profile</a></li><li><a href="start.html"  class="action logout" rel="nofollow" title="Logout">Logout</a></li>                </ul>
            </div>
        -->

        <!-- SEARCH TOOLS -->
<!--
        <div id="dokuwiki__searchtools">
            <h3 class="a11y"></h3>
            <form action="../../start.html" accept-charset="utf-8" class="search" id="dw__search" method="get" role="search"><div class="no"><input type="hidden" name="do" value="search" /><input type="text" id="qsearch__in" accesskey="f" name="id" class="edit" title="[F]" /><input type="submit" value="Search" class="button" title="Search" /><div id="qsearch__out" class="ajax_qsearch JSpopup"></div></div></form>        </div>
-->

        <!-- SITE TOOLS -->
<!--
        <div id="dokuwiki__sitetools">
            <h3 class="a11y">Site Tools</h3>
                            <div class="mobileTools">
                    <form action="../..//doku.html.doku.php.html" method="get" accept-charset="utf-8"><div class="no"><input type="hidden" name="id" value="tutorial:synthesis:buck:start" /><input type="hidden" name="sectok" value="5951012722f577fca2f46d1d7dc103a2" /><select name="do" class="edit quickselect" title="Tools"><option value="">Tools</option><optgroup label="Page Tools"><option value="edit">Edit this page</option><option value="revisions">Old revisions</option><option value="backlink">Backlinks</option></optgroup><optgroup label="Site Tools"><option value="recent">Changes</option><option value="media">Manager</option><option value="index">Sitemap</option></optgroup><optgroup label="User Tools"><option value="logout">Logout</option><option value="profile">Profile</option><option value="admin">Admin</option></optgroup></select><input type="submit" value="&gt;" /></div></form>                </div>
                <ul>
                    <li><a href="start.html"  class="action recent" accesskey="r" rel="nofollow" title="Changes [R]">Changes</a></li><li><a href="start.html"  class="action media" rel="nofollow" title="Manager">Manager</a></li><li><a href="start.html"  class="action index" accesskey="x" rel="nofollow" title="Sitemap [X]">Sitemap</a></li>                </ul>
                    </div>
    </div>
-->

    <!-- BREADCRUMBS -->
        
    <hr class="a11y" />
</div></div><!-- /header -->

        <div class="wrapper group">

            
            <!-- ********** CONTENT ********** -->
            <div id="dokuwiki__content"><div class="pad group">
                <div class="pageId"><span>tutorial:synthesis:buck:start</span></div>
                <div class="page group">
                                                            <!-- wikipage start -->
                    <!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="#modelling">Modelling</a></div></li>
<li class="level1"><div class="li"><a href="#verification_of_specification">Verification of specification</a></div></li>
<li class="level1"><div class="li"><a href="#synthesis">Synthesis</a></div></li>
<li class="level1"><div class="li"><a href="#circuit_capturing">Circuit capturing</a></div></li>
<li class="level1"><div class="li"><a href="#verification_of_implementation">Verification of implementation</a></div></li>
<li class="level1"><div class="li"><a href="#alternative_implementations_optional">Alternative implementations (optional)</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="#standard-c_implementation">Standard-C implementation</a></div></li>
<li class="level2"><div class="li"><a href="#logic_decomposition_and_technology_mapping">Logic decomposition and technology mapping</a></div></li>
</ul>
</li>
<li class="level1"><div class="li"><a href="#solutions">Solutions</a></div></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 id="synthesis_and_verification_of_buck_controller">Synthesis and verification of buck controller</h1>
<div class="level1">

<p>
<a href="http://en.wikipedia.org/wiki/Buck converter" class="interwiki iw_wp" title="http://en.wikipedia.org/wiki/Buck converter">Buck converter</a> is a voltage step down and current step up converter. It comprises an analogue buck and its digital control logic as shown in the following diagram. Your task in this tutorial is to formally specify, synthesise and verify the control circuitry of the buck.
</p>

<p>
<img src="schematic-buck.png" class="mediacenter" title="Schematic" alt="Schematic" />
</p>

<p>
The controller switches the power regulating PMOS and NMOS transistors ON and OFF as a reaction to under-voltage (UV), over-current (OC) and zero-crossing (ZC) conditions. These conditions are detected and signalled by a set of specialised sensors implemented as comparators of measured current and voltage levels against some reference values (<code>I_max</code>, <code>V_0</code>, <code>V_ref</code>). Note that the <code><span style='color:blue; '>gp</span></code> and <code><span style='color:blue; '>gn</span></code> signals are buffered to drive the very large power regulating transistors (occupy more than 50% of the buck area) and their effect on the buck can be significantly delayed. Therefore, the controller is explicitly notified (by the <code><span style='color:red; '>gp_ack</span></code> and <code><span style='color:red; '>gn_ack</span></code> signals) when the power transistor threshold levels (<code>Th_pmos</code> and <code>Th_nmos</code>) are crossed.
</p>

<p>
The operation of a buck is usually specified in an intuitive, but rather informal way, e.g. by enumerating the possible sequences of detected conditions and describing the intended reaction to them, as in the following phase diagram.
<img src="pd-buck.png" class="mediacenter" title="Informal specification using phase diagrams" alt="Informal specification using phase diagrams" />
</p>

<p>
This specification reveals an alternation of the UV and OC conditions which are handled by switching the power regulating PMOS and NMOS transistors of the buck ON and OFF. Detection of the ZC condition after UV does not change this behaviour, however, if ZC is detected before UV then both the PMOS and NMOS transistors remain OFF until the UV event. 
</p>

<p>
It is important to note that in order to avoid a short-circuit the PMOS and NMOS transistors of the buck must never be ON at the same time.
</p>

</div>

<h2 id="modelling">Modelling</h2>
<div class="level2">

<p>
According to the phase diagram there are three distinctive scenarios to capture:
</p>
<ul>
<li class="level1"><div class="li">
 <strong>no ZC</strong> – UV happens without ZC;
</div></li>
<li class="level1"><div class="li">
 <strong>late ZC</strong> – UV is followed by ZC;
</div></li>
<li class="level1"><div class="li">
 <strong>early ZC</strong> – UV happens after ZC. 
</div></li>
</ul>


<p>
Let us first capture the <strong>no ZC</strong> scenario as an STG.
</p>
<p><a class="folder" href="#folded_1">Detailed instructions </a></p><div class="folded hidden" id="folded_1"><ul>
<li class="level1"><div class="li">
 Initially the NMOS transistor is ON and the PMOS transistor is OFF which should lead to the UV condition:
</div><ul>
<li class="level2"><div class="li">
 Create a place <code>p0</code> and mark it with a token - this denotes the initial state. 
</div></li>
<li class="level2"><div class="li">
 Create a rising phase of an input signal and call it <code><span style='color:red; '>uv+</span></code>.
</div></li>
<li class="level2"><div class="li">
 Connect the place <code>p0</code> to the transition <code><span style='color:red; '>uv+</span></code>.
</div></li>
</ul>
</li>
<li class="level1"><div class="li">
 When UV is detected the NMOS transistor needs to be switched OFF:
</div><ul>
<li class="level2"><div class="li">
 Create an output transition <code><span style='color:blue; '>gn-</span></code>. 
</div></li>
<li class="level2"><div class="li">
 Connect <code><span style='color:red; '>uv+</span></code> to <code><span style='color:blue; '>gn-</span></code>.
</div></li>
</ul>
</li>
<li class="level1"><div class="li">
 Wait for indication of NMOS transistor being OFF:
</div><ul>
<li class="level2"><div class="li">
 Create an input transition <code><span style='color:red; '>gn_ack-</span></code>.
</div></li>
<li class="level2"><div class="li">
 Connect <code><span style='color:blue; '>gn-</span></code> to <code><span style='color:red; '>gn_ack-</span></code>,
</div></li>
</ul>
</li>
<li class="level1"><div class="li">
 When the OFF state of NMOS is confirmed the PMOS transistor can be set ON to charge the buck:
</div><ul>
<li class="level2"><div class="li">
 Create an output transition <code><span style='color:blue; '>gp+</span></code> and an input transition <code><span style='color:red; '>gp_ack+</span></code>. 
</div></li>
<li class="level2"><div class="li">
 Connect <code><span style='color:red; '>gn_ack-</span></code> to <code><span style='color:blue; '>gp+</span></code> and <code><span style='color:blue; '>gp+</span></code> to <code><span style='color:red; '>gp_ack+</span></code>.
</div></li>
</ul>
</li>
<li class="level1"><div class="li">
 Eventually the buck will saturate leading to reset of UV and OC conditions:
</div><ul>
<li class="level2"><div class="li">
 Create input transitions <code><span style='color:red; '>uv-</span></code> and <code><span style='color:red; '>oc+</span></code>.
</div></li>
<li class="level2"><div class="li">
 Connect <code><span style='color:red; '>gp_ack+</span></code> to <code><span style='color:red; '>uv-</span></code> and <code><span style='color:red; '>uv-</span></code> to <code><span style='color:red; '>oc+</span></code>.
</div></li>
</ul>
</li>
<li class="level1"><div class="li">
 At this stage the PMOS transistor needs to be switched OFF:
</div><ul>
<li class="level2"><div class="li">
 Create an output transition <code><span style='color:blue; '>gp-</span></code> and an input transition <code><span style='color:red; '>gp_ack-</span></code>.
</div></li>
<li class="level2"><div class="li">
 Connect <code><span style='color:red; '>oc+</span></code> to <code><span style='color:blue; '>gp-</span></code> and <code><span style='color:blue; '>gp-</span></code> to <code><span style='color:red; '>gp_ack-</span></code>.
</div></li>
</ul>
</li>
<li class="level1"><div class="li">
 After the OFF state of the PMOS transistor is confirmed the NMOS transistor is switched ON state:
</div><ul>
<li class="level2"><div class="li">
 Create an output transition <code><span style='color:blue; '>gn+</span></code> and an input transition <code><span style='color:red; '>gn_ack+</span></code>.
</div></li>
<li class="level2"><div class="li">
 Connect <code><span style='color:red; '>gp_ack-</span></code> to <code><span style='color:blue; '>gn+</span></code> and <code><span style='color:blue; '>gn+</span></code> to <code><span style='color:red; '>gn_ack+</span></code>.
</div></li>
</ul>
</li>
<li class="level1"><div class="li">
 This leads to the release of OC and brings the controller to the initial state:
</div><ul>
<li class="level2"><div class="li">
 Create an input transition <code><span style='color:red; '>oc-</span></code>.
</div></li>
<li class="level2"><div class="li">
 Connect <code><span style='color:red; '>gn_ack+</span></code> to <code><span style='color:red; '>oc-</span></code>.
</div></li>
<li class="level2"><div class="li">
 Connect <code><span style='color:red; '>oc-</span></code> to the place <code>p0</code>.
</div></li>
</ul>
</li>
</ul>

</div>
<p>
The resulting STG listing the sequence of signal events for this scenario is shown in the following diagram. Save this model as <em>stg-buck-scenario1_no_zc</em> file.
</p>

<p>
<img src="stg-buck-scenario1_no_zc.png" class="mediacenter" alt="" />
</p>

<p>
The scenario for <em>late ZC</em> is formalised in a very similar way. Both phases of ZC just happen concurrently with setting NMOS transistor OFF and PMOS transistor ON.
</p>
<ul>
<li class="level1"><div class="li"> Copy and save the <em>no ZC</em> scenario with new name <em>stg-buck-scenario2_late_zc</em>.</div>
</li>
<li class="level1"><div class="li"> Create two input signal transitions <code><span style='color:red; '>zc+</span></code> and <code><span style='color:red; '>zc-</span></code>.</div>
</li>
<li class="level1"><div class="li"> Connect <code><span style='color:red; '>uv+</span></code> to <code><span style='color:red; '>zc+</span></code>.</div>
</li>
<li class="level1"><div class="li"> Connect <code><span style='color:red; '>zc+</span></code> to <code><span style='color:red; '>zc-</span></code>.</div>
</li>
<li class="level1"><div class="li"> Connect <code><span style='color:red; '>zc-</span></code> to <code><span style='color:red; '>uv-</span></code>.</div>
</li>
</ul>

<p>
The resulting STG should look similar to the following diagram. Do not forget to save the work!
</p>

<p>
<img src="stg-buck-scenario2_late_zc.png" class="mediacenter" alt="" />
</p>

<p>
The scenario for early arrival of ZC is a bit different. Here the NMOS transistor needs to be switched OFF  as soon as ZC is detected, without waiting for UV. However, switching the PMOS transistor ON is still delayed till UV condition.
</p>
<ul>
<li class="level1"><div class="li"> Copy and save the late ZC model under new name <em>stg-buck-scenario3_early_zc</em>.</div>
</li>
<li class="level1"><div class="li"> Delete incoming and outgoing arcs of <code><span style='color:red; '>uv+</span></code> and <code><span style='color:red; '>zc+</span></code> transitions (just select the arc and press <kbd>Delete</kbd>).</div>
</li>
<li class="level1"><div class="li"> Connect place <code>p0</code> to <code><span style='color:red; '>zc+</span></code> and <code><span style='color:red; '>zc+</span></code> to <code><span style='color:blue; '>gn-</span></code>.</div>
</li>
<li class="level1"><div class="li"> Connect <code><span style='color:red; '>zc+</span></code> to <code><span style='color:red; '>uv+</span></code> and <code><span style='color:red; '>uv+</span></code> to <code><span style='color:blue; '>gp+</span></code>.</div>
</li>
<li class="level1"><div class="li"> Connect <code><span style='color:blue; '>gp+</span></code> to <code><span style='color:red; '>zc-</span></code>.</div>
</li>
<li class="level1"><div class="li"> Rearrange transitions to make the STG look nicer (using the selection tool) and save the work.</div>
</li>
</ul>

<p>
The STG for early ZC scenario should look similar to the following diagram.
</p>

<p>
<img src="stg-buck-scenario3_early_zc.png" class="mediacenter" alt="" />
</p>

<p>
In order to produce an implementation capable of handling all of the scenarios, these STGs need to be merged into a single specification.One can see that all three STGs have ‘compatible’ initial states, that is all common input and output signals are set to the same values initially. Therefore one can merge the initially marked place in the three STGs and obtain a combined specification for buck control.
</p>
<ul>
<li class="level1"><div class="li">
 Create a new STG work called <em>stg-buck-scenarios_merged</em>.
</div></li>
<li class="level1"><div class="li">
 Insert the STG for no ZC scenario by selecting <em>File→Merge work…</em> menu item and choosing the <em>stg-buck-scenario1_no_zc</em> file. After insertion the whole STG is selected - drag-and-drop it aside of the centre as the following steps will insert STGs there.
</div></li>
<li class="level1"><div class="li">
 Similarly insert the STG for early ZC scenario (<em>stg-buck-scenario3_early_zc</em> file) and drag it below the no ZC scenario.
</div></li>
<li class="level1"><div class="li">
 Finally insert the STG for late ZC scenario (<em>stg-buck-scenario2_late_zc</em> file) and drag it above the previously inserted ones.
</div></li>
<li class="level1"><div class="li">
 Now as you have STGs for all three scenarios in the same work space remove the initial place in two of the scenarios (e.g. in late ZC and early ZC) and reuse the remaining place instead.
</div></li>
</ul>


<p>
The STG combining all three scenarios should look like the following diagram. Do not forget to save the work!
</p>

<p>
<img src="stg-buck-scenarios_merged.png" class="mediacenter" alt="" />
</p>
<div class="wrap_info plugin_wrap">
<p>
Note that this STG is <em>non-deterministic</em>, e.g. after <code><span style='color:red; '>uv+</span></code> fires the STG can end up in either of the two possible states. Non-determinism is common in scenario-based modelling, and can be very powerful and expressive. Occasionally, the scenarios may impose conflicting requirements on the system (e.g. two scenarios may have a common prefix, with one of them requiring and the other forbidding the circuit to produce a particular output after this prefix). Such conflicting requirements can be detected during verification. In this model, however, the scenarios are compatible.
</p>
</div><div class="wrap_info plugin_wrap">
<h4 id="optional_simplification">Optional simplification</h4>

<p>
Once the initially marked places are merged, one can notice that three transitions <code><span style='color:red; '>oc-</span></code> leading to it can also be merged because their preceding states are ‘compatible’. This process continues with signal event <code><span style='color:red; '>gn_ack+</span></code>, and so on, ‘zipping’ the common paths of the STGs together. The simplified STG specification of the buck control is as follows; save it as <em>stg-buck-simplified</em> file.
</p>

<p>
<img src="stg-buck-simplified.png" class="mediacenter" alt="" />
</p>

<p>
Note that this STG is just a cosmetic improvement over the previous one and this step can safely be skipped. This does not affect the verification and synthesis, but it does improve the visual representation and thus is important from the designer&#039;s perspective.
</p>
</div>
</div>

<h2 id="verification_of_specification">Verification of specification</h2>
<div class="level2">

<p>
Activate the <strong>simulation tool</strong> <img src="../../help/editor_tools-simulate.png" class="media" title="[M] Simulate" alt="[M] Simulate" /> and exercise the obtained STG model. Click one of the enabled signal transitions (they are highlighted in orange) to <em>evaluate</em> the STG into the next state. Make sure the simulation traces correspond to those intended by the informal specification of the phase diagram.
</p>

<p>
Before proceeding to the synthesis step verify the specification for consistency (i.e. that the rising and falling phases of each signal alternate in all possible execution traces), deadlock-freeness and output-persistency. These can be done via <em>Verification</em> menu. 
</p>

<p>
Another property one has to verify is that PMOS and NMOS transistors are never ON simultaneously (which would lead to a short-circuit), i.e. that signals <code><span style='color:blue; '>gp</span></code> and <code><span style='color:blue; '>gn</span></code> are never high at the same time. This custom property can be formulated as a reachability analysis problem using <a href="../../help/reach.html" class="wikilink1" title="help:reach">Reach language</a>:
</p>
<ul>
<li class="level1"><div class="li">
 Open the <em>Custom property definition</em> window by selecting <em>Verification→Custom properties [MPSat]…</em> menu.
</div></li>
<li class="level1"><div class="li">
 In <em>MPSat settings</em> set the <em>Mode</em> into <em>STG reachability analysis</em> and the <em>Solution</em> into <em>minimise cost function</em>.
</div></li>
<li class="level1"><div class="li">
 Enter a Reach expression that identifies the short-circuit, i.e. both <code><span style='color:blue; '>gp</span></code> and <code><span style='color:blue; '>gn</span></code> signals are high – <code>$S&quot;gp&quot; &amp; $S&quot;gn&quot;</code>.<sup><a href="#fn__1" id="fnt__1" class="fn_top">1)</a></sup>
</div></li>
<li class="level1"><div class="li">
 Select <em>unsatisfiable</em> to denote that the property holds if predicate is unsatisfiable.
</div></li>
<li class="level1"><div class="li">
 Save this property as a preset for future use, e.g. under the name <em>short circuit check</em>.
</div></li>
</ul>


<p>
The whole custom property window should look as follows.
</p>

<p>
<img src="property_check-short_circuit.png" class="mediacenter" alt="" />
</p>

<p>
When you click the <em>Run</em> button the STG will be searched for a state where the Reach expression evaluates to <em>True</em>. If such a state exists then the Reach predicate is satisfiable and the property is violated. Otherwise, the property holds.
</p>

<p>
If the verified property is violated then a trace leading to the problematic state is reported. This trace can be simulated to diagnose the problem and correct it at the level of STG specification.
</p>

<p>
Note that the property that signals <code><span style='color:blue; '>gp</span></code> and <code><span style='color:blue; '>gn</span></code> are never high at the same time is not sufficient to guarantee the absence of short-circuits. Indeed, the PMOS and NMOS transistors are big and slow, and so if e.g. <code><span style='color:blue; '>gp+</span></code> happens immediately after <code><span style='color:blue; '>gn-</span></code>, a transient short-circuit may be possible even though the property holds. In fact, the signals <code><span style='color:red; '>gp_ack</span></code> and <code><span style='color:red; '>gn_ack</span></code> were introduced specifically to detect the completion of the switching of the corresponding transistors, making it possible to avoid such short-circuits. Hence, a stronger correctness property ensuring that <code><span style='color:blue; '>gp</span></code> cannot be high whenever <code><span style='color:blue; '>gn</span></code> or <code><span style='color:red; '>gn_ack</span></code> is high, and similarly <code><span style='color:blue; '>gn</span></code> cannot be high whenever <code><span style='color:blue; '>gp</span></code> or <code><span style='color:red; '>gp_ack</span></code> is high, can be formulated as follows: <code>($S&quot;gp&quot; | $S&quot;gp_ack&quot;) &amp; ($S&quot;gn&quot; | $S&quot;gn_ack&quot;)</code>.<sup><a href="#fn__2" id="fnt__2" class="fn_top">2)</a></sup> Verify that this stronger property also holds for the above STG model.
</p>

</div>

<h2 id="synthesis">Synthesis</h2>
<div class="level2">

<p>
The STG specification can now be synthesised into an asynchronous circuit implementation either with Petrify or MPSat backend tools via <em>Synthesis</em> menu.
</p>

<p>
A complex-gate solution obtained with Petrify (via <em>Complex gate [Petrify]</em> menu) is as follows (<span class="wrap_important ">note that solution is not unique and you may get a slightly different set of equations</span>):
</p>
<pre class="code">[gp] = uv gn_ack&#039; + gp_ack oc&#039;; 
[gn] = zc&#039; uv&#039; gp_ack&#039;; </pre>

<p>
Using De Morgan&#039;s law one can derive the following negative gate implementation:
</p>
<pre class="code">[gp] = ((gn_ack + uv&#039;) (oc + gp_ack&#039;))&#039;; 
[gn] = (zc + uv + gp_ack)&#039;; </pre>

<p>
These equations can be mapped to complex-gates with the following functions: <code>Z=((A+B&#039;)*(C+D&#039;))&#039;</code> for <code><span style='color:blue; '>gp</span></code> and <code>Z=(A+B+C)&#039;</code> for <code><span style='color:blue; '>gn</span></code>. Let us call the former gate <em>OAI2I2I</em> and the later <em>NR3</em>.
</p>
<div class="wrap_info plugin_wrap">
<p>
Circuit designers use hardware description languages, such as <a href="http://en.wikipedia.org/wiki/Verilog" class="interwiki iw_wp" title="http://en.wikipedia.org/wiki/Verilog">Verilog</a> or <a href="http://en.wikipedia.org/wiki/VHDL" class="interwiki iw_wp" title="http://en.wikipedia.org/wiki/VHDL">VHDL</a>, to precisely describe the circuit. For example, the association of the ports to the gates&#039; pins can be described by the following Verilog module (if you are not familiar with Verilog you can safely skip this part as it is not required by the rest of the tutorial):
</p>
<pre class="code verilog"><span class="kw1">module</span> control <span class="br0">&#40;</span>oc<span class="sy0">,</span> uv<span class="sy0">,</span> zc<span class="sy0">,</span> gp_ack<span class="sy0">,</span> gn_ack<span class="sy0">,</span> gp<span class="sy0">,</span> gn<span class="br0">&#41;</span><span class="sy0">;</span>
  <span class="kw1">input</span> oc<span class="sy0">,</span> uv<span class="sy0">,</span> zc<span class="sy0">;</span>
  <span class="kw1">input</span> gp_ack<span class="sy0">,</span> gn_ack<span class="sy0">;</span>
  <span class="kw1">output</span> gp<span class="sy0">,</span> gn<span class="sy0">;</span>
  OAI2I2I inst_gp <span class="br0">&#40;</span>.A<span class="br0">&#40;</span>gn_ack<span class="br0">&#41;</span><span class="sy0">,</span> .B<span class="br0">&#40;</span>uv<span class="br0">&#41;</span><span class="sy0">,</span> .C<span class="br0">&#40;</span>oc<span class="br0">&#41;</span><span class="sy0">,</span> .D<span class="br0">&#40;</span>gp_ack<span class="br0">&#41;</span><span class="sy0">,</span> .Z<span class="br0">&#40;</span>gp<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
  NR3 inst_gn <span class="br0">&#40;</span>.A<span class="br0">&#40;</span>zc<span class="br0">&#41;</span><span class="sy0">,</span> .B<span class="br0">&#40;</span>uv<span class="br0">&#41;</span><span class="sy0">,</span> .C<span class="br0">&#40;</span>gp_ack<span class="br0">&#41;</span><span class="sy0">,</span> .Z<span class="br0">&#40;</span>gn<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw1">endmodule</span></pre>
</div>
</div>

<h2 id="circuit_capturing">Circuit capturing</h2>
<div class="level2">
<div class="wrap_info plugin_wrap">
<p>
Workcraft can automatically derive a circuit from the synthesis output of Petrify. For this open the <em>Edit→Preferences…</em> window and under <em>Models→Digital Circuit</em> leaf enable the <em>Import synthesis result</em> checkbox. However, for the purpose of this exercise please capture the circuit schematics manually.
</p>
</div>
<p>
Create a new Digital Circuit work called <em>circuit-buck-cg</em> and capture the implementation suggested by Petrify in the form of a gate-level netlist. 
</p>
<ul>
<li class="level1"><div class="li">
 Create a Digital Circuit work <em>circuit-buck-cg</em>.
</div></li>
<li class="level1"><div class="li">
 Add a functional component with the set function <code>((A + B&#039;) * (C + D&#039;))&#039;</code>.<sup><a href="#fn__3" id="fnt__3" class="fn_top">3)</a></sup> Rename it to <code>inst_gp</code> and change its rendering type to <em>GATE</em>.
</div></li>
<li class="level1"><div class="li">
 Add a functional component with the set function <code>(A + B + C)&#039;</code>.<sup><a href="#fn__4" id="fnt__4" class="fn_top">4)</a></sup> Rename it to <code>inst_gn</code> and change its rendering type to <em>GATE</em>.
</div></li>
<li class="level1"><div class="li">
 Create two output ports <code><span style='color:blue; '>gp</span></code> and <code><span style='color:blue; '>gn</span></code>. 
</div></li>
<li class="level1"><div class="li">
 Connect the output of <code>inst_gp</code> to the <code><span style='color:blue; '>gp</span></code> port and the output of <code>inst_gn</code> gate to the <code><span style='color:blue; '>gn</span></code> port.
</div></li>
<li class="level1"><div class="li">
 Create input ports <code><span style='color:red; '>gn_ack</span></code>, <code><span style='color:red; '>oc</span></code>, <code><span style='color:red; '>uv</span></code>, <code><span style='color:red; '>zc</span></code> and <code><span style='color:red; '>gp_ack</span></code>.
</div></li>
<li class="level1"><div class="li">
 Connect the input port to the corresponding pins of the <code>inst_gp</code> and <code>inst_gn</code> gates. To fork a wire just start a connection from an existing wire - a joint point will be automatically created.
</div></li>
<li class="level1"><div class="li">
 Set the initial state of <code><span style='color:blue; '>gn</span></code> and <code><span style='color:red; '>gn_ack</span></code> signals to <code>1</code>. For this select the corresponding ports and in the <em>Property editor</em> tick the <em>Init to one</em> check box.
</div></li>
</ul>


<p>
The captured circuit should look as follows: 
</p>

<p>
<img src="circuit-buck-cg.png" class="mediacenter" alt="" />
</p>

</div>

<h2 id="verification_of_implementation">Verification of implementation</h2>
<div class="level2">

<p>
Activate the <strong>simulation tool</strong> <img src="../../help/editor_tools-simulate.png" class="media" title="[M] Simulate" alt="[M] Simulate" /> and simulate the captured complex gate implementation of the buck control. Ports, pins and wires are colour-coded: blue means low level and red means high level of the signal. Excited pins and ports are highlighted in orange. 
</p>

<p>
Click an excited pin to toggle its logical value – the circuit will evaluate to the next state where new set of signals will be enabled. The sequence of signal events is recorded in the simulation trace and can be subsequently replayed for analysing the circuit&#039;s behaviour.
</p>

<p>
Note that switching of input ports is not restricted. Environment can change them at any time causing unspecified behaviour of the circuit. One can restrict this behaviour by composing the circuit with the original STG specification of its contract with the environment:
</p>
<ul>
<li class="level1"><div class="li">
 Activate <strong>selection tool</strong> and make sure nothing is selected – the Property editor will show the properties of the whole circuit.
</div></li>
<li class="level1"><div class="li">
 Click the <em>Environment <abbr title="Uniform Resource Identifier">URI</abbr></em> property - a file browser will pop up. Locate the <em>stg-buck-scenarios_merged</em> file and open it. A path to that file will be copied to the <em>Environment <abbr title="Uniform Resource Identifier">URI</abbr></em> property.<sup><a href="#fn__5" id="fnt__5" class="fn_top">5)</a></sup>
</div></li>
</ul>


<p>
Now circuit verification will be conducted in the context of the environment that behaves according to STG in <em>stg-buck-scenarios_merged</em> file. Check the circuit for hazards, deadlocks and verify that it conforms to the environment specification. All these verification steps can be run via <em>Verification→Conformation, deadlock and hazard (reuse unfolding) [MPSat]</em> menu.
</p>

<p>
Try to alter the circuit and verify if it still conforms to the environment, is deadlock-free and operates without hazards.
</p>

</div>

<h2 id="alternative_implementations_optional">Alternative implementations (optional)</h2>
<div class="level2">

<p>
When synthesising a complex-gate implementation with MPSat (via <em>Complex gate [MPSat]</em> menu), three alternative implementations of <code><span style='color:blue; '>gp</span></code> are computed:
</p>
<pre class="code">Signal gp (cost 4)
Triggers (underapproximation): oc uv gn_ack
Context: gp
Equation (4 lits): uv gn_ack&#039; + oc&#039; gp
Context: zc
Equation (4 lits): gn_ack&#039; (oc&#039; zc&#039; + uv)
Context: gp_ack
Equation (4 lits): uv gn_ack&#039; + oc&#039; gp_ack</pre>

<p>
Note that:
</p>
<ul>
<li class="level1"><div class="li">
 The last implementation coincides with the one obtained by Petrify.
</div></li>
<li class="level1"><div class="li">
 Signals <code><span style='color:red; '>oc</span></code>, <code><span style='color:red; '>uv</span></code>, and <code><span style='color:red; '>gn_ack</span></code> are the <em>triggers</em> of <code><span style='color:blue; '>gp</span></code>, i.e. their firing can enable <code><span style='color:blue; '>gp</span></code>.
</div><ul>
<li class="level2"><div class="li">
 The triggers can be found by inspecting the STG: there are arcs <code><span style='color:red; '>gn_ack-</span></code> → <code><span style='color:blue; '>gp+</span></code> (in each of the three scenarios), <code><span style='color:red; '>uv+</span></code> → <code><span style='color:blue; '>gp+</span></code> (in the “early ZC” scenario), and <code><span style='color:red; '>oc+</span></code> → <code><span style='color:blue; '>gp-</span></code> (in the reset part).
</div></li>
<li class="level2"><div class="li">
 Triggers are always in the support — they occur in each of the three equations above.
</div></li>
</ul>
</li>
<li class="level1"><div class="li">
 Different <em>context</em> signals can be added to the triggers to form a support, in this case either of <code><span style='color:blue; '>gp</span></code>, <code><span style='color:red; '>zc</span></code> or <code><span style='color:red; '>gp_ack</span></code> can be used.
</div></li>
</ul>


<p>
The first implementation uses <code><span style='color:blue; '>gp</span></code> itself as a context signal, which results in a gate with feedback:
</p>

<p>
<img src="circuit-buck-cg-feedback.png" class="mediacenter" alt="" />
</p>

<p>
This implementation is particularly interesting, as it suggests that <code><span style='color:blue; '>gp</span></code> might be implemented by a latch (i.e. a state-holding element) rather than a combinational gate. Below we explore some such implementations.
</p>

</div>

<h3 id="standard-c_implementation">Standard-C implementation</h3>
<div class="level3">

<p>
The <em>standard-C architecture</em> (a.k.a. <em>“monotonic covers”</em>) is shown in the picture below. It uses a C-element as the state-holding element that is driven by two combinational gates computing the <em>Set</em> and <em>Reset functions</em> of the implemented signal.
</p>

<p>
<img src="circuit-standard-c-architecture.png" class="mediacenter" alt="" />
</p>

<p>
The standard-C implementation of the buck STG can be synthesised using <em>Synthesis→Standard C-element [MPSat]</em> menu as follows (<span class="wrap_important ">note that solution is not unique and you may get a slightly different set of equations</span>):
</p>
<pre class="code">SOLUTION 0:
Signal gn SET (cost 2)
Triggers (underapproximation): gp_ack
Context: oc gn
Equation (2 lits): oc gp_ack&#039;
Context: uv zc gn
Equation (3 lits): uv&#039; zc&#039; gp_ack&#039;

SOLUTION 1:
Signal gn RESET (cost 2)
Triggers (underapproximation): uv zc
Context: gn
Equation (2 lits): zc + uv

SOLUTION 2:
Signal gp SET (cost 2)
Triggers (underapproximation): uv gn_ack
Context: gp
Equation (2 lits): uv gn_ack&#039;

SOLUTION 3:
Signal gp RESET (cost 1)
Triggers (underapproximation): oc
Context: gp
Equation (1 lits): oc</pre>

<p>
These equations provide the Set and Reset functions for <code><span style='color:blue; '>gn</span></code> and <code><span style='color:blue; '>gp</span></code>. Note that:
</p>
<ul>
<li class="level1"><div class="li">
 Two alternative implementations are suggested for the Set function of <code><span style='color:blue; '>gn</span></code>.
</div></li>
<li class="level1"><div class="li">
 There is no benefit in implementing <code><span style='color:blue; '>gn</span></code> using standard-C architecture,<sup><a href="#fn__6" id="fnt__6" class="fn_top">6)</a></sup> as the original complex-gate implementation is simpler.
</div></li>
<li class="level1"><div class="li">
 The standard-C implementation of <code><span style='color:blue; '>gp</span></code> is nicer than the complex-gate one, in particular it does away with that ugly 4-input gate that may be absent from the gate library.
</div></li>
</ul>


<p>
The resulting circuit is as follows:
</p>

<p>
<img src="circuit-buck-cg-decomposed-monot.png" class="mediacenter" alt="" />
</p>
<div class="wrap_important plugin_wrap">
<p>
Do not forget to verify this solution w.r.t. the original STG as described above for the complex-gate implementation! In theory, the synthesised implementation is correct-by-construction, but in practice tools have bugs <img src="../../lib/images/smileys/icon_sad.gif" class="icon" alt=":-(" />
</p>
</div>
</div>

<h3 id="logic_decomposition_and_technology_mapping">Logic decomposition and technology mapping</h3>
<div class="level3">

<p>
Complex-gate and standard-C syntheses are oblivious to the gate library. Hence, the implementations they yield may be too large to be implemented by a single gate available in the gate library. Unfortunately, breaking up a gate into smaller ones, when performed naïvely, generally yields an incorrect circuit. In fact, logic decomposition in the context of speed-independent circuits is a very difficult problem, that cannot always be solved. Petrify and MPSat backend tools do a good job in many situations, but occasionally they fail to converge to a solution and a manual intervention by the designer is required.
</p>

<p>
Currently the gate library called <code>petrify.lib</code> is used for technology mapping. The decomposed and mapped implementation of the buck STG can be synthesised using <em>Synthesis→Technology mapping [Petrify]</em> or <em>Synthesis→Technology mapping [MPSat]</em> menu. E.g. Petrify&#039;s solution is as follows (<span class="wrap_important ">note that solution is not unique and you may get a slightly different set of equations</span>):
</p>
<pre class="code">[gn] = zc&#039; uv&#039; gp_ack&#039;; 	   # gate nor3:combinational
#PRAGMA: zero delay
[1] = uv&#039;; 	   # gate inv:combinational
#PRAGMA: zero delay
[2] = gp&#039;; 	   # gate inv:combinational
[gp] = [2]&#039; oc&#039; + [1]&#039; gn_ack&#039;; 	   # gate oai22:combinational</pre>

<p>
This solution corresponds to the original complex-gate implementation: <code><span style='color:blue; '>gn</span></code> is implemented by gate <code>nor3:combinational</code>, and <code><span style='color:blue; '>gp</span></code> is implemented by two inverters <code>inv:combinational</code> and gate <code>oai22:combinational</code>. The two <code>#PRAGMA</code>s state the assumption that the delays of the two inverters must be negligible. This is usually unproblematic as long as such input inverters are placed next to the main gate, but in some situations this assumption may be questionable; moreover, this assumption introduces extra constraints that have to be satisfied during placing and routing.
</p>

<p>
Let us try to decompose the implementation of <code><span style='color:blue; '>gp</span></code> into gates/latches with at most two inputs. In the <em>Edit→Preferences</em> dialog, select <em>External tools→MPSat</em> and type <code>-g2</code> in the <em>Additional arguments</em> property. This will pass an extra command line option to MPSat, which will restrict it to gates/latches with at most two inputs. Then select <em>Synthesis→Technology mapping [MPSat]</em> to obtain the following implementation of <code><span style='color:blue; '>gp</span></code> (<span class="wrap_important ">note that solution is not unique and you may get a slightly different set of equations</span>):
</p>
<pre class="code">Signal gp (cost 72)
Triggers (underapproximation): oc uv gn_ack
Context: gp
Equation: gn_ack&#039; (oc&#039; zc&#039; + uv)
Gate rs_nor:asynch, sub-functions:
	gn_ack + oc		or2:combinational (inversions: 00|0)
	uv		delay:asynch (inversions: 0|0)</pre>
<div class="wrap_important plugin_wrap">
<p>
Do not forget to delete the <code>-g2</code> option from the preferences, to prevent permanently restricting MPSat to 2-input gates!
</p>
</div>
<p>
This implementation of <code><span style='color:blue; '>gp</span></code> uses reset-dominant RS latch <code>rs_nor:asynch</code> and  gate <code>or2:combinational</code> (<code>delay:asynch</code> is just a wire — there is no need to insert an explicit delay). 
</p>
<div class="wrap_info plugin_wrap">
<p>
MPSat also finds a decomposition of <code><span style='color:blue; '>gn</span></code> into 2-input gates/latches, which is the same as the standard-C implementation considered above. However, the complex-gate implementation of <code><span style='color:blue; '>gn</span></code> was already good enough, and so we are only interested in decomposing the implementation of <code><span style='color:blue; '>gp</span></code>.
</p>
</div>
<p>
This circuit can be captured in Workcraft as follows:
</p>

<p>
<img src="circuit-buck-cg-decomposed-rs.png" class="mediacenter" alt="" />
</p>

<p>
Note that the properties for the reset dominant RS latch are set as follows: <em>Render type</em> is <em>Box</em>, <em>Set function</em> is <code>R&#039;*S</code>, and <em>Reset function</em> is <code>R</code>.
</p>

<p>
This solution has no input inverters and is implementable in most gate libraries.
</p>
<div class="wrap_important plugin_wrap">
<p>
Do not forget to verify this solution w.r.t. the original STG as described above for the complex-gate implementation! In theory, the synthesised implementation is correct-by-construction, but in practice tools have bugs <img src="../../lib/images/smileys/icon_sad.gif" class="icon" alt=":-(" />
</p>
</div>
</div>

<h2 id="solutions">Solutions</h2>
<div class="level2">

<p>
Download all the Workcraft models discussed in this tutorial here:
</p>

<p>
<span class="wrap_download "><a href="buck.zip" class="media mediafile mf_zip" title="tutorial:synthesis:buck:buck.zip (37.9 KB)">Buck control models</a> (37.86 KiB, <acronym title="Modified: 2015-07-05 19:33.34">4w ago</acronym>)</span>
</p>

</div>
<div class="footnotes">
<div class="fn"><sup><a href="#fnt__1" id="fn__1" class="fn_bot">1)</a></sup> 
Here <code>$S</code> means the value of a signal, <code>&quot;gp&quot;</code> and <code>&quot;gn&quot;</code> are the names of the signals and <code>&amp;</code> is Boolean AND.</div>
<div class="fn"><sup><a href="#fnt__2" id="fn__2" class="fn_bot">2)</a></sup> 
Here <code>|</code> is Boolean OR.</div>
<div class="fn"><sup><a href="#fnt__3" id="fn__3" class="fn_bot">3)</a></sup> 
, <sup><a href="#fnt__4" id="fn__4" class="fn_bot">4)</a></sup> 
Notice the use of <code>&#039;</code> symbol for negation.</div>
<div class="fn"><sup><a href="#fnt__5" id="fn__5" class="fn_bot">5)</a></sup> 
If the file does not exist then its name is shown in red.</div>
<div class="fn"><sup><a href="#fnt__6" id="fn__6" class="fn_bot">6)</a></sup> 
In some situations, e.g. if there are only 2-input gates/latches in the gate library, this standard-C implementation may come useful.</div>
</div>

                    <!-- wikipage stop -->
                                    </div>
<!--
                                    <div class="docInfo"><bdi>tutorial/synthesis/buck/start.txt</bdi> · Last modified: 2015/07/31 22:41 by <bdi>danil</bdi></div>
                -->
                            </div></div><!-- /content -->

            <hr class="a11y" />

            <!-- PAGE ACTIONS -->
<!--
            <div id="dokuwiki__pagetools">
                            <h3 class="a11y">Page Tools</h3>
                <div class="tools">
                    <ul>
                        <li><a href="start.html"  class="action edit" accesskey="e" rel="nofollow" title="Edit this page [E]"><span>Edit this page</span></a></li><li><a href="start.html"  class="action revs" accesskey="o" rel="nofollow" title="Old revisions [O]"><span>Old revisions</span></a></li><li><a href="start.html"  class="action backlink" rel="nofollow" title="Backlinks"><span>Backlinks</span></a></li><li><a href="#dokuwiki__top"  class="action top" accesskey="t" rel="nofollow" title="Back to top [T]"><span>Back to top</span></a></li><li><a href="start.html"  class="action export_pdf" rel="nofollow" title="Export to PDF"><span>Export to PDF</span></a></li><li><a href="start.html"  class="action siteexport_addpage" title="Add page"><span>Export Page</span></a></li>                    </ul>
                </div>
                        </div>
-->
        </div><!-- /wrapper -->

        
<!-- ********** FOOTER ********** -->
<div id="dokuwiki__footer"><div class="pad">
    <!--
    <div class="buttons">
                <a href="http://www.dokuwiki.org/donate" title="Donate" ><img
            src="../../lib/tpl/dokuwiki-light-export/images/button-donate.gif" width="80" height="15" alt="Donate" /></a>
        <a href="http://www.php.net" title="Powered by PHP" ><img
            src="../../lib/tpl/dokuwiki-light-export/images/button-php.gif" width="80" height="15" alt="Powered by PHP" /></a>
        <a href="http://validator.w3.org/check/referer" title="Valid HTML5" ><img
            src="../../lib/tpl/dokuwiki-light-export/images/button-html5.png" width="80" height="15" alt="Valid HTML5" /></a>
        <a href="http://jigsaw.w3.org/css-validator/check/referer?profile=css3" title="Valid CSS" ><img
            src="../../lib/tpl/dokuwiki-light-export/images/button-css.png" width="80" height="15" alt="Valid CSS" /></a>
        <a href="http://dokuwiki.org/" title="Driven by DokuWiki" ><img
            src="../../lib/tpl/dokuwiki-light-export/images/button-dw.png" width="80" height="15" alt="Driven by DokuWiki" /></a>
    </div>
-->

<!--
    <div class="userInfo">
        Logged in as:: danil    </div>
-->
</div></div><!-- /footer -->

    </div></div><!-- /site -->

    <div class="no"><img  width="2" height="1" alt="" /></div>
    <div id="screen__mode" class="no"></div>    <!--[if ( lte IE 7 | IE 8 ) ]></div><![endif]-->
</body>
</html>

